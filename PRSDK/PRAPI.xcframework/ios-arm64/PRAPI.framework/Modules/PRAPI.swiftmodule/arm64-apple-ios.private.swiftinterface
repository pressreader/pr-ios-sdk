// swift-interface-format-version: 1.0
// swift-compiler-version: Apple Swift version 6.1.2 effective-5.10 (swiftlang-6.1.2.1.2 clang-1700.0.13.5)
// swift-module-flags: -target arm64-apple-ios16.0 -enable-objc-interop -enable-library-evolution -swift-version 5 -enforce-exclusivity=checked -O -enable-experimental-feature DebugDescriptionMacro -enable-bare-slash-regex -module-name PRAPI
// swift-module-flags-ignorable: -no-verify-emitted-module-interface -interface-compiler-version 6.1.2
import AVFoundation
import AppTrackingTransparency
import AuthenticationServices
import Combine
import CommonCrypto
import CommonCrypto.CommonCryptor
import CoreData
import CoreLocation
import Foundation
import GCDWebServers
import PRUtils.NSDictionary_CIKey
import PRUtils.NSNotificationCenter_PRExtension
@_exported import PRAPI
import PRAlertKit
import PRAnalytics
import PRCatalogModel
import PRCommands
import PRConfiguration
import PRCoreDataUtils
import PRDIContainer
import PRIAPReceipt
import PRLogKit.PRLog
import PRLogKit
import PRPromiseKit
import PRProtocols
import PRSmart
import PRSyntacticSugar
import PRThumbnail
import PRUtils
import StoreKit
import Swift
import UIKit
import WidgetKit
import _Concurrency
import _StringProcessing
import _SwiftConcurrencyShims
@objc @_Concurrency.MainActor @preconcurrency final public class WebAuthenticationSession : AuthenticationServices.ASWebAuthenticationSession {
  @objc @_Concurrency.MainActor @preconcurrency public init?(provider: Swift.String, extKey: Swift.String, onlineToken: Swift.String, linkToCurrentAccount: Swift.Bool, completion: @escaping (_ success: Swift.Bool, _ isNewUser: Swift.Bool, (any Swift.Error)?) -> ())
  @objc deinit
}
extension AuthenticationServices.ASWebAuthenticationSession : @retroactive AuthenticationServices.ASWebAuthenticationPresentationContextProviding {
  @_Concurrency.MainActor @preconcurrency @objc dynamic public func presentationAnchor(for session: AuthenticationServices.ASWebAuthenticationSession) -> AuthenticationServices.ASPresentationAnchor
}
@objc public protocol RichMediaAnalyticsProvider : PRAnalytics.AnalyticsProvider {
  @objc var mediaType: Swift.String { get }
  @objc var issue: (any PRAPI.IssueAnalyticsProvider)? { get }
  @objc var mediaTitle: Swift.String? { get }
}
@objc public protocol RichMediaPhotoAnalyticsProvider : PRAPI.RichMediaAnalyticsProvider {
  @objc var photosCount: Swift.Int { get }
  @objc var photoIndex: Swift.Int { get }
}
extension PRAPI.RichMediaAnalyticsProvider {
  public func trackRichMedia(action: PRAnalytics.RMTAction)
}
extension PRAPI.RichMediaPhotoAnalyticsProvider {
  public func trackRichMedia(action: PRAnalytics.RMTAction)
}
@objc final public class SearchHistoryItem : ObjectiveC.NSObject {
  @objc final public let title: Swift.String
  @objc public init(title: Swift.String)
  @objc deinit
}
@objc extension PRAPI.PRSubscription {
  @objc @discardableResult
  dynamic public func getOnboardingStatus() -> PRPromiseKit.Promise
  @objc @discardableResult
  dynamic public func updateOnboardingStatus(_ status: PRAPI.PROnboardingStatus) -> PRPromiseKit.Promise
}
public enum ServiceError : Swift.Error {
  case noServiceUrlProvided
  case unsupportedSection
  case unexpectedResponse
  case unexpectedError
  case noContent
  case busy
  case disabled
  public static func == (a: PRAPI.ServiceError, b: PRAPI.ServiceError) -> Swift.Bool
  public func hash(into hasher: inout Swift.Hasher)
  public var hashValue: Swift.Int {
    get
  }
}
@available(*, unavailable)
@objc extension Foundation.NSError {
  @objc public static let unexpectedResponse: Foundation.NSError
}
@_inheritsConvenienceInitializers final public class BookSectionDataSource : PRAPI.CatalogSectionDataSource, PRAPI.SectionDataSourceProtocol {
  @objc final public var section: PRConfiguration.PRCatalogSectionType {
    @objc get
  }
  override public init?(entity: PRCatalogModel.CatalogEntity)
  @objc deinit
}
@objc @objcMembers final public class FacebookSignInResult : PRAPI.SignInResult {
  @objc final public let isNewUser: Swift.Bool
  @objc final public let isSuccess: Swift.Bool
  @objc public init(isNewUser: Swift.Bool, isSuccess: Swift.Bool, accessToken: Swift.String? = nil, error: (any Swift.Error)? = nil)
  @objc deinit
}
@objc extension CoreData.NSManagedObject {
  @objc dynamic public var coreDataController: PRAPI.PRCoreDataController? {
    @objc get
  }
  @objc override dynamic open func post(_ notificationName: Foundation.NSNotification.Name, userInfo: [Swift.AnyHashable : Any]? = nil)
}
@objc @_inheritsConvenienceInitializers @_hasMissingDesignatedInitializers @_Concurrency.MainActor final public class CatalogItemDownloadService : ObjectiveC.NSObject {
  public enum LoadingError : Swift.Error {
    case unexpected
    case noContentInfo
    case unsupportedFormat
    public static func == (a: PRAPI.CatalogItemDownloadService.LoadingError, b: PRAPI.CatalogItemDownloadService.LoadingError) -> Swift.Bool
    public func hash(into hasher: inout Swift.Hasher)
    public var hashValue: Swift.Int {
      get
    }
  }
  @objc @_Concurrency.MainActor public static let shared: PRAPI.CatalogItemDownloadService
  @_Concurrency.MainActor final public func download(_ item: PRCatalogModel.CatalogItem, contentOptions: PRCatalogModel.CatalogItemContentOption = []) async throws
  @_Concurrency.MainActor final public func download(_ item: PRCatalogModel.CatalogItem, contentOptions: PRCatalogModel.CatalogItemContentOption = [], itemInfo: inout PRAPI.CatalogServiceItemInfo) async throws
  @_Concurrency.MainActor final public func download(_ item: PRCatalogModel.Book, contentOptions: PRCatalogModel.CatalogItemContentOption = [], itemInfo: inout PRAPI.CatalogServiceItemInfo) async throws
  @objc @_Concurrency.MainActor final public func cancelDownload(_ item: PRCatalogModel.CatalogItem)
  @discardableResult
  @objc @_Concurrency.MainActor final public func removeFromDownloads(_ items: [PRCatalogModel.CatalogItem]) async throws -> Swift.Bool
  @objc deinit
}
extension PRAPI.BookService {
  @_Concurrency.MainActor final public func loadEntity<T>(id: Swift.String, type: T.Type, context: CoreData.NSManagedObjectContext) async throws -> T where T : PRCatalogModel.CatalogEntity
}
@objc @_inheritsConvenienceInitializers @objcMembers final public class AppleSignInStorage : ObjectiveC.NSObject {
  @objc final public class var storedCredential: AuthenticationServices.ASAuthorizationAppleIDCredential? {
    @objc get
  }
  @objc final public class func saveCredentials(_ credentials: AuthenticationServices.ASAuthorizationAppleIDCredential)
  @objc final public class func removeStoredCredentials()
  @objc final public class func validateStoredCredentials()
  @objc override dynamic public init()
  @objc deinit
}
@objc @objcMembers final public class CatalogSectionScheme : ObjectiveC.NSObject {
  @objc final public let type: PRConfiguration.PRCatalogSectionType
  @objc final public let name: Swift.String
  @objc final public let sortingOrder: PRConfiguration.PRCatalogSortingOrder
  @objc final public let sortingOrderForSubsection: PRConfiguration.PRCatalogSortingOrder
  @objc final public let layoutType: PRAPI.PRLayoutType
  @objc final public let options: PRAPI.CatalogSectionSchemeOption
  @objc final public let customTitle: Swift.String?
  @objc final public let cids: [Swift.String]?
  @objc final public let categories: [Swift.String]?
  @objc final public var isModernAPISupported: Swift.Bool {
    @objc get
  }
  @objc override final public var debugDescription: Swift.String {
    @objc get
  }
  @objc public init(name: Swift.String, sortingOrder: PRConfiguration.PRCatalogSortingOrder, sortingOrderForSubsection: PRConfiguration.PRCatalogSortingOrder, layoutType: PRAPI.PRLayoutType, options: PRAPI.CatalogSectionSchemeOption, customTitle: Swift.String? = nil, cids: [Swift.String]? = nil, categories: [Swift.String]? = nil)
  @objc deinit
}
@objc @_inheritsConvenienceInitializers public class CatalogCoreDataController : PRAPI.PRCoreDataController {
  @objc override dynamic public var managedObjectModelName: Swift.String {
    @objc get
  }
  @objc override dynamic public var databaseName: Swift.String {
    @objc get
  }
  @objc override dynamic public var managedObjectModelBundle: Foundation.Bundle? {
    @objc get
  }
  public func getCatalog(context: CoreData.NSManagedObjectContext) -> PRCatalogModel.PressCatalog
  public func getDownloads(context: CoreData.NSManagedObjectContext) -> PRCatalogModel.Downloads
  @objc override dynamic public init()
  @objc deinit
}
@objc public enum ArticleTranslationState : Swift.Int {
  case none = 0, shortContent, full
  public init?(rawValue: Swift.Int)
  public typealias RawValue = Swift.Int
  public var rawValue: Swift.Int {
    get
  }
}
@objc extension PRSmart.PRSmartArticle {
  @objc dynamic public var translationState: PRAPI.ArticleTranslationState {
    @objc get
  }
}
public protocol LibraryService {
  associatedtype Item : PRCatalogModel.CatalogItem
  func updateLibrary(item: Self.Item) async throws
  func removeItemFromLibrary(_ item: Self.Item) async throws
}
@objc public protocol MastheadProvider {
  @objc var hasMasthead: Swift.Bool { get }
  @objc func masthead(height: CoreFoundation.CGFloat, style: UIKit.UIUserInterfaceStyle, handler: @escaping PRThumbnail.PRThumbnailHandler)
}
extension PRAPI.MastheadProvider {
  public func mastheadTemplate(height: CoreFoundation.CGFloat, handler: @escaping PRThumbnail.PRThumbnailHandler)
}
public enum MastheadLoadingError : Swift.Error {
  case unknown
  case unavailable
  public static func == (a: PRAPI.MastheadLoadingError, b: PRAPI.MastheadLoadingError) -> Swift.Bool
  public func hash(into hasher: inout Swift.Hasher)
  public var hashValue: Swift.Int {
    get
  }
}
@objc extension PRAPI.PRSourceList {
  @objc dynamic public var presentationOptions: PRAPI.CatalogPresentationOption {
    @objc get
    @objc set
  }
  @objc dynamic public var titleObjects: [any PRAPI.PRTitleObject] {
    @objc get
  }
  @objc dynamic public var containsTitleItems: Swift.Bool {
    @objc get
  }
  @objc dynamic public func sortList()
  @objc dynamic public func filterList()
  @objc dynamic public func filter(id: PRAPI.CatalogNavigationType) -> PRAPI.PRSourceListFilter?
  @objc dynamic public func copyMe() -> Self
  @objc dynamic public func catalogSlice(filter: any PRAPI.CatalogNavigation, scheme: PRAPI.CatalogSectionScheme?) -> Self
  @objc dynamic public func customCatalogCatalogSlice() -> Self
  @objc dynamic public func semiplainSlice() -> Self
  @objc dynamic public func favouritesSlice(order: PRConfiguration.PRCatalogSortingOrder) -> Self
  @objc dynamic public func latestPublishDaySlice(order: PRConfiguration.PRCatalogSortingOrder) -> Self
  @objc dynamic public func notifyAboutDataChange()
  @objc @available(*, unavailable)
  dynamic public func collectionContainsEdition(_ collection: Swift.Array<any PRAPI.PRTitleObject>, of item: any PRAPI.PRTitleObject) -> Swift.Bool
}
extension PRAPI.PRSourceList : PRSyntacticSugar.Emptiable {
}
@objc extension PRAPI.PRCatalog {
  @objc dynamic public func isReady() -> Swift.Bool
}
public enum FeaturedAudioAction : Swift.String {
  case swipe
  case play
  case read
  public init?(rawValue: Swift.String)
  public typealias RawValue = Swift.String
  public var rawValue: Swift.String {
    get
  }
}
public protocol FeaturedAudioAnalyticsProvider : PRAnalytics.AnalyticsProvider {
}
extension PRAPI.FeaturedAudioAnalyticsProvider {
  public func trackFeaturedAudio(action: PRAPI.FeaturedAudioAction, article: (any PRAPI.NTFArticle)?)
}
extension PRAPI.PublicationService : PRAPI.NavigableCatalogService {
  @_Concurrency.MainActor final public func loadFilters(scope: PRCatalogModel.CatalogEntity?) async throws -> [PRCatalogModel.CatalogFilter]
  @_Concurrency.MainActor final public func processNavigationInfo(_ json: [Swift.String : Any], scope: PRCatalogModel.CatalogEntity?) throws -> [PRCatalogModel.CatalogFilter]
}
@objc extension PRAPI.NTFDataItem {
  @objc dynamic public var defaultContent: PRAPI.DataItemContent? {
    @objc get
  }
  @objc dynamic public var defaultPayload: PRUtils.NSDictionaryCIWrapper? {
    @objc get
  }
  @objc dynamic public func content(language: Swift.String) -> PRAPI.DataItemContent?
  @objc dynamic public func payload(language: Swift.String) -> PRUtils.NSDictionaryCIWrapper?
  @objc dynamic public func updateContent(json: [Swift.String : Any], language: Swift.String)
}
public enum RadioAction : Swift.String {
  case firstStart
  case pauseRestart
  case complete
  public init?(rawValue: Swift.String)
  public typealias RawValue = Swift.String
  public var rawValue: Swift.String {
    get
  }
}
@objc public protocol RadioAnalyticsProvider : PRAnalytics.AnalyticsProvider {
  @objc var dataSourceItem: PRAPI.PRSourceItem? { get }
  @objc var currentSmartArticle: PRSmart.PRSmartArticle { get }
  @objc var currentFeedArticle: (any PRAPI.NTFArticle)? { get }
}
extension PRAPI.RadioAnalyticsProvider {
  public func trackRadio(action: PRAPI.RadioAction? = nil)
}
public struct PartnerBanner {
  public let logoId: Swift.String
  public let text: Swift.String
  public let textColor: UIKit.UIColor
  public let background: PRAPI.Background
}
extension PRAPI.PartnerBanner : Swift.Codable {
  public init(from decoder: any Swift.Decoder) throws
  public func encode(to encoder: any Swift.Encoder) throws
}
extension PRAPI.PRDownloadedSourceList {
  @objc override dynamic public var presentationOptions: PRAPI.CatalogPresentationOption {
    @objc get
    @objc set
  }
  @objc dynamic public func startObservation()
}
public protocol BookReadingAnalyticsProvider : PRAPI.BookAnalyticsProvider {
}
extension PRAPI.BookReadingAnalyticsProvider {
  public func trackBookReaderOpen()
}
@_inheritsConvenienceInitializers @objc @_Concurrency.MainActor @preconcurrency final public class AppleSignInManager : PRAPI._PRSocialManager, AuthenticationServices.ASAuthorizationControllerDelegate, AuthenticationServices.ASAuthorizationControllerPresentationContextProviding {
  @_Concurrency.MainActor @preconcurrency @objc final public func authorizationController(controller: AuthenticationServices.ASAuthorizationController, didCompleteWithAuthorization authorization: AuthenticationServices.ASAuthorization)
  @_Concurrency.MainActor @preconcurrency @objc final public func authorizationController(controller: AuthenticationServices.ASAuthorizationController, didCompleteWithError error: any Swift.Error)
  @_Concurrency.MainActor @preconcurrency @objc final public func presentationAnchor(for controller: AuthenticationServices.ASAuthorizationController) -> AuthenticationServices.ASPresentationAnchor
  @_Concurrency.MainActor @preconcurrency @objc override dynamic public init()
  @objc deinit
}
extension PRAPI.AppleSignInManager : PRAPI.SignInManagerProtocol {
  public typealias ResultType = PRAPI.AppleSignInResult
  @objc @_Concurrency.MainActor @preconcurrency public static let shared: PRAPI.AppleSignInManager
  @objc @_Concurrency.MainActor @preconcurrency final public func signIn(_ handler: @escaping (PRAPI.AppleSignInResult) -> ())
}
extension PRAPI.NTFArticleItem {
  @objc dynamic public func updateAccessibility()
  public func updateAccessibility(saveToPersitentStore: Swift.Bool = false)
}
@objc @_inheritsConvenienceInitializers @_Concurrency.MainActor final public class BookUserService : PRAPI.BookSubservice {
  public struct RefreshOption : Swift.OptionSet {
    public static let forceUpdate: PRAPI.BookUserService.RefreshOption
    public var rawValue: Swift.Int
    public init(rawValue: Swift.Int)
    public typealias ArrayLiteralElement = PRAPI.BookUserService.RefreshOption
    public typealias Element = PRAPI.BookUserService.RefreshOption
    public typealias RawValue = Swift.Int
  }
  @_Concurrency.MainActor override public init?(bookService: PRAPI.BookService)
  @_Concurrency.MainActor final public func loadBookReadingPosition(bookId: Swift.String) async throws -> PRAPI.BookReadingPosition?
  @_Concurrency.MainActor final public func uploadBookReadingPosition(_ position: PRAPI.BookReadingPosition.Position, bookId: Swift.String) async throws
  @_Concurrency.MainActor final public func refreshBookLibrary(options: PRAPI.BookUserService.RefreshOption = []) async throws -> Swift.Bool
  @_Concurrency.MainActor override final public func preload() async
  @objc deinit
}
extension PRAPI.BookUserService : PRAPI.LibraryService {
  public typealias Item = PRCatalogModel.Book
  @_Concurrency.MainActor final public func updateLibrary(item: PRAPI.BookUserService.Item) async throws
  @_Concurrency.MainActor final public func removeItemFromLibrary(_ item: PRAPI.BookUserService.Item) async throws
}
extension PRCatalogModel.CatalogItem : PRAPI.PRCatalogItem {
  @objc dynamic public var sourceType: PRCatalogModel.PRSourceType {
    @objc get
  }
  @objc dynamic public var cid: Swift.String {
    @objc get
  }
  @objc dynamic public var date: Foundation.Date? {
    @objc get
  }
  @objc dynamic public var sortingDate: Foundation.Date? {
    @objc get
  }
  @objc dynamic public var size: Swift.UInt {
    @objc get
  }
  @objc dynamic public var originCountryCode: Swift.String? {
    @objc get
  }
}
extension PRCatalogModel.CatalogFilter {
  final public var variantType: PRCatalogModel.CatalogEntity.Type {
    get
  }
  final public func split() -> [any PRAPI.CatalogNavigation]
}
extension PRCatalogModel.CatalogFilter : PRAPI.CatalogNavigation {
  @objc final public var options: [PRAPI.CatalogNavigationSection] {
    @objc get
  }
  @objc final public var name: Swift.String {
    @objc get
  }
  @objc final public var type: PRAPI.CatalogNavigationType {
    @objc get
  }
  @objc final public var value: Any? {
    @objc get
  }
  @objc final public var catalogType: PRAPI.CatalogType {
    @objc get
  }
}
@_inheritsConvenienceInitializers @objc(PRPianoManager) @objcMembers final public class PianoManager : ObjectiveC.NSObject {
  public typealias SignInCompletion = (Swift.Bool, (any Swift.Error)?) -> ()
  public typealias SignOutCompletion = ((any Swift.Error)?) -> ()
  @objc public static let shared: PRAPI.PianoManager?
  @objc public static var isEnabled: Swift.Bool {
    @objc get
  }
  @objc public static var urlPrefix: Swift.String {
    @objc get
  }
  @objc final public func signIn(_ completion: @escaping PRAPI.PianoManager.SignInCompletion)
  @objc final public func signOut(_ completion: @escaping PRAPI.PianoManager.SignOutCompletion)
  @objc final public func application(_ application: UIKit.UIApplication, open url: Foundation.URL, options: [UIKit.UIApplication.OpenURLOptionsKey : Any]) -> Swift.Bool
  @objc @discardableResult
  final public func application(_ application: UIKit.UIApplication, didFinishLaunchingWithOptions launchOptions: [UIKit.UIApplication.LaunchOptionsKey : Any]?) -> Swift.Bool
  @objc override dynamic public init()
  @objc deinit
}
extension PRAPI.NTFArticleItem : PRAPI.MastheadProvider {
  @objc dynamic public var hasMasthead: Swift.Bool {
    @objc get
  }
  @objc dynamic public func masthead(height: CoreFoundation.CGFloat, style: UIKit.UIUserInterfaceStyle, handler: @escaping PRThumbnail.PRThumbnailHandler)
}
extension PRAPI.Interest {
  public func getFeed() -> PRAPI.NTFFeed
}
extension PRAPI.NTFDataService {
  public enum DataServiceError : Swift.Error {
    case unknown
    public static func == (a: PRAPI.NTFDataService.DataServiceError, b: PRAPI.NTFDataService.DataServiceError) -> Swift.Bool
    public func hash(into hasher: inout Swift.Hasher)
    public var hashValue: Swift.Int {
      get
    }
  }
  @objc public static func requestArticlesJSON(articleIds: Swift.String, viewType: Swift.String, parameters: [Swift.String : Any]) async throws -> [[Swift.String : Any]]
  @objc dynamic public func waitForOtherDataSuppliers() async
  public func requestData() async throws
  @objc dynamic public func deleteFeed()
  @objc dynamic public func feed(context: CoreData.NSManagedObjectContext) -> PRAPI.NTFFeed?
}
@_hasMissingDesignatedInitializers final public class MultipleLatestIssueDataSource : PRAPI.CatalogItemDataSource {
  @objc override final public var canLoadMore: Swift.Bool {
    @objc get
  }
  convenience public init(sourceList: PRAPI.PRLatestIssuesList)
  public init(cids: [Swift.String])
  @objc override final public func load() -> Swift.Bool
  override final public func startLoading()
  @objc deinit
}
extension PRAPI.PRAccountManager {
  public var isDefaultAccountUnregistered: Swift.Bool {
    get
  }
  public var isDefaultAccountAuthorizationNeeded: Swift.Bool {
    get
  }
}
@_inheritsConvenienceInitializers @objc(PRBrazeProxy) @objcMembers final public class BrazeProxy : ObjectiveC.NSObject {
  public static let shared: (any PRAPI.PRBraze)?
  @objc override dynamic public init()
  @objc deinit
}
extension UIKit.UIAlertController {
  @objc @_Concurrency.MainActor @preconcurrency public static func showNetworkNotReachableAlert()
  @_Concurrency.MainActor @preconcurrency public static func showNoResultAlert()
  @objc @_Concurrency.MainActor @preconcurrency public static func showErrorAlert(message: Swift.String)
  @objc @_Concurrency.MainActor @preconcurrency public static func showServiceErrorAlert(message: Swift.String)
  @objc @_Concurrency.MainActor @preconcurrency public static func showDebugAlert(message: Swift.String, sendLogs: Swift.Bool = false)
}
extension PRCatalogModel.Books : PRAPI.PressCatalogable {
  public typealias Service = PRAPI.BookService
  final public var service: PRAPI.BookService? {
    get
  }
}
@objc extension PRAPI.PROptions {
  @objc dynamic public var appBundle: Foundation.Bundle {
    @objc get
  }
  @objc dynamic public var booksAvailable: Swift.Bool {
    @objc get
  }
  @objc dynamic public func deleteDocuments() throws
}
@objc extension PRAPI.PRTitleItem {
  @objc dynamic public func issueVersion(date: Foundation.Date) -> Swift.Int
  @objc dynamic public func expungeVersion(date: Foundation.Date) -> Swift.String
}
extension PRAPI.PRSocialSignInManager {
  @objc dynamic public func appleLogin(_ handler: @escaping PRAPI.SignInCompletion)
  @objc dynamic public func appleRequestPublishPermission(_ ai: PRAPI.PRAccountItem, linkToCurrentAccount: Swift.Bool, completion handler: @escaping PRAPI.ExternalAuthCompletion)
}
@objc @objcMembers final public class Sponsorship : ObjectiveC.NSObject, PRAnalytics.Sponsorship {
  @objc final public var hotSpotId: Swift.String? {
    @objc get
  }
  @objc final public var isAvailable: Swift.Bool {
    @objc get
  }
  @objc final public var isInArea: Swift.Bool {
    @objc get
  }
  @objc final public var status: PRAnalytics.SponsorshipStatus {
    @objc get
  }
  @objc final public var isActive: Swift.Bool {
    @objc get
  }
  @objc final public var isHotSpotEnabled: Swift.Bool {
    @objc get
  }
  @objc final public var isGeoFence: Swift.Bool {
    @objc get
  }
  @objc final public var industry: Swift.String? {
    @objc get
  }
  @objc final public var hotSpotName: Swift.String? {
    @objc get
  }
  @objc final public var hotSpotSessionExpiration: Foundation.Date {
    @objc get
  }
  @objc final public var radiantAccessExpiration: Foundation.Date {
    @objc get
  }
  @objc final public var isExpired: Swift.Bool {
    @objc get
  }
  @nonobjc final public var partnerBanner: PRAPI.PartnerBanner? {
    get
    set
  }
  @objc final public var hotSpotTitles: PRAPI.HotSpotTitles? {
    @objc get
    @objc set
  }
  @objc public init(account: PRAPI.PRAccountItem)
  @objc deinit
}
extension PRAPI.PRAccountItem {
  @objc dynamic public var sponsorship: PRAPI.Sponsorship {
    @objc get
  }
}
public struct MimeType {
  public var value: Swift.String {
    get
  }
  public init(path: Swift.String)
  public init(path: Foundation.NSString)
  public init(url: Foundation.URL)
}
@objc public protocol NTFItem : ObjectiveC.NSObjectProtocol, PRAPI.MastheadProvider {
}
extension Swift.Array where Element == any PRAPI.NTFArticle {
  public var ntfItems: [any PRAPI.NTFItem] {
    get
  }
}
@objc extension PRAPI.PublicationChannel {
  @objc dynamic public var isFollowed: Swift.Bool {
    @objc get
  }
  @objc dynamic public var mastheadProvider: (any PRAPI.MastheadProvider)? {
    @objc get
  }
}
@objc extension PRSmart.PRSmartArticle {
  @objc dynamic public var isPreview: Swift.Bool {
    @objc get
  }
  @objc dynamic public var hasOnlineContent: Swift.Bool {
    @objc get
  }
  @objc dynamic public var hasDownloadedContent: Swift.Bool {
    @objc get
  }
  @objc dynamic public var titleExemplar: PRAPI.PRTitleItemExemplar? {
    @objc get
  }
  @objc dynamic public var mli: PRAPI.PRMyLibraryItem? {
    @objc get
  }
  @objc(needsDataUpdateForLanguage:) dynamic public func needsDataUpdate(for languageISO: Swift.String) -> Swift.Bool
}
extension PRAPI.NTFSession {
  public func object<T>(predicate: Swift.String, context: CoreData.NSManagedObjectContext) -> T where T : CoreData.NSManagedObject
  public func object<T>(predicate: Swift.String, context: CoreData.NSManagedObjectContext) -> T? where T : CoreData.NSManagedObject
}
extension StoreKit.SKProduct : @retroactive PRAnalytics.AnalyticsProvider {
  public func track()
}
extension PRAPI.PRSourceItem {
  public func isAutoDeliverable() -> (hasSubscription: Swift.Bool, includingSupplements: Swift.Bool)
  public func setAutodelivery(_ isOn: Swift.Bool, applyToSupplements: Swift.Bool = false, completion: ((Swift.Bool, (any Swift.Error)?) -> Swift.Void)? = nil)
}
extension PRAPI.PRSourceItem : PRAnalytics.AnalyticsProvider {
}
@objc @_inheritsConvenienceInitializers final public class GoogleSignInResult : PRAPI.SignInResult {
  @objc override public init(userId: Swift.String? = nil, accessToken: Swift.String? = nil, identityToken: Swift.String? = nil, email: Swift.String? = nil, firstName: Swift.String? = nil, lastName: Swift.String? = nil, displayName: Swift.String? = nil, profileImageUrl: Swift.String? = nil, error: (any Swift.Error)? = nil)
  @objc deinit
}
final public class BookLicenseProduct : Swift.Decodable, Swift.Hashable {
  public struct Term : Swift.Decodable {
    public let duration: Swift.Int?
    public let units: Swift.String?
    public init(from decoder: any Swift.Decoder) throws
  }
  public struct Sponsor : Swift.Decodable {
    public let id: Swift.String
    public let name: Swift.String
    public init(from decoder: any Swift.Decoder) throws
  }
  final public let id: Swift.String
  final public let title: Swift.String
  final public let token: Swift.String
  final public let currency: Swift.String?
  final public let price: Swift.Float
  final public let formattedPrice: Swift.String
  final public let discount: Swift.Float
  final public let formattedDiscount: Swift.String
  final public let total: Swift.Float
  final public let formattedTotal: Swift.String
  final public let isAutoRenewEnabled: Swift.Bool
  final public let autoRenewProduct: PRAPI.BookLicenseProduct?
  final public let giftProduct: PRAPI.BookLicenseProduct?
  final public let features: [Swift.String]?
  final public let tags: [Swift.String]?
  final public let term: PRAPI.BookLicenseProduct.Term?
  final public let sponsor: PRAPI.BookLicenseProduct.Sponsor?
  final public var isFree: Swift.Bool {
    get
  }
  final public func hash(into hasher: inout Swift.Hasher)
  public static func == (lhs: PRAPI.BookLicenseProduct, rhs: PRAPI.BookLicenseProduct) -> Swift.Bool
  @objc deinit
  final public var hashValue: Swift.Int {
    get
  }
  public init(from decoder: any Swift.Decoder) throws
}
public protocol ColoredEntity {
  var color: UIKit.UIColor { get }
  var titleHash: Swift.Int { get }
}
extension PRAPI.ColoredEntity {
  public var availableColors: [Swift.UInt] {
    get
  }
  public var color: UIKit.UIColor {
    get
  }
}
extension PRAPI.Interest : PRAPI.ColoredEntity {
  public var titleHash: Swift.Int {
    get
  }
}
extension PRCatalogModel.Book : PRAPI.ColoredEntity {
  final public var titleHash: Swift.Int {
    get
  }
}
@objc @_inheritsConvenienceInitializers @objcMembers final public class CatalogPresentationOption : PRSyntacticSugar.PROptionSet {
  @objc public static let representsTitleItemExemplars: PRAPI.CatalogPresentationOption
  @objc public static let prefersOpeningReaderView: PRAPI.CatalogPresentationOption
  @objc required public init(rawValue: Swift.Int)
  public typealias ArrayLiteralElement = PRAPI.CatalogPresentationOption
  public typealias Element = PRAPI.CatalogPresentationOption
  public typealias RawValue = Swift.Int
  @objc deinit
}
extension PRAPI.PRCatalog {
  @available(swift, obsoleted: 1.0)
  @objc(presenter) dynamic public var _presenter: any PRAPI.CatalogFacade {
    @objc get
  }
  public var presenter: any PRAPI.ObservableCatalogFacade {
    get
  }
  public var facade: any PRAPI.ObservableCatalogFacade {
    get
  }
  public var favoriteCountries: [any PRAPI.CountryNavigationVariant] {
    get
  }
  @objc dynamic public func favorites(order: PRConfiguration.PRCatalogSortingOrder = .notDefined) -> [any PRAPI.PRCatalogItem]
}
public protocol DeviceTimeTweakProtected : ObjectiveC.NSObjectProtocol {
  var lastPermissionRequestDate: Foundation.Date? { get set }
  func updateLastPermissionRequestDateIfValid() -> Swift.Bool
}
extension PRAPI.DeviceTimeTweakProtected {
  public var lastPermissionRequestDate: Foundation.Date? {
    get
    set
  }
  public func updateLastPermissionRequestDateIfValid() -> Swift.Bool
}
public protocol BrazeEntity {
  var extras: [Swift.AnyHashable : Any]? { get }
}
extension PRAPI.BrazeEntity {
  public var isEligible: Swift.Bool {
    get
  }
}
@available(*, unavailable)
@objc extension ObjectiveC.NSObject {
  @objc dynamic public var isEligibleBrazeEntity: Swift.Bool {
    @objc get
  }
}
public protocol ContentCard : PRAPI.BrazeEntity {
  var id: Swift.String { get }
  var title: Swift.String { get }
  var details: Swift.String { get }
  var imageUrl: Swift.String { get }
  var url: Swift.String? { get }
  func logImpression()
  func logClick()
  func logDismission()
}
@objc public protocol ServiceReachabilityObserver {
  @objc func serviceReachabilityDidChange(status: PRAPI.PRAccountItemReachabilityStatus)
}
extension PRAPI.ServiceReachabilityObserver {
  public var isServiceReachable: Swift.Bool {
    get
  }
  public func startServiceReachabilityObservation()
  public func stopServiceReachabilityObservation()
}
@available(*, unavailable)
@objc extension ObjectiveC.NSObject {
  @objc dynamic public func _startServiceReachabilityObservation()
  @objc dynamic public func _stopServiceReachabilityObservation()
}
public protocol ArticleSearchAnalyticsProvider : PRAnalytics.AnalyticsProvider {
  var articlesCount: Swift.Int { get }
  var specificInfo: PRAnalytics.AnalyticsParameters { get }
}
extension PRAPI.ArticleSearchAnalyticsProvider {
  public var specificInfo: PRAnalytics.AnalyticsParameters {
    get
  }
  public func trackMoreArticlesLoaded()
}
public struct CatalogServiceItemInfo {
  public var gracePeriodAddedMessage: Swift.String?
  public init()
}
extension Foundation.NSNotification.Name {
  public static let catalogPreloaded: Foundation.Notification.Name
  public static let catalogReloaded: Foundation.Notification.Name
}
@objc extension Foundation.NSNotification {
  @objc public static let catalogPreloaded: Foundation.Notification.Name
}
@_inheritsConvenienceInitializers @_Concurrency.MainActor public class CatalogService<T> : PRAPI.MOService<T, PRAPI.CatalogCoreDataController>, PRAPI.Preloadable where T : PRAPI.PressCatalogable {
  nonisolated public var updateInterval: Foundation.TimeInterval {
    get
  }
  @_Concurrency.MainActor final public func updateCatalog(forced: Swift.Bool) async
  @_Concurrency.MainActor final public func loadBatch(entity: PRCatalogModel.CatalogEntity) async throws -> [PRCatalogModel.CatalogItem]
  @_Concurrency.MainActor final public var preloadTask: _Concurrency.Task<(), Swift.Never>? {
    get
    set
  }
  @_Concurrency.MainActor public func preload() async
  @_Concurrency.MainActor public func cancelPreloading()
  override nonisolated public init(item: T)
  @objc deinit
}
extension PRAPI.CatalogService : @preconcurrency PRAPI.LoadableCatalog {
  @_Concurrency.MainActor public func catalog(context: CoreData.NSManagedObjectContext) -> (any PRAPI.PressCatalogable)?
}
public protocol SearchHistoryAnalyticsProvider : PRAnalytics.AnalyticsProvider {
}
extension PRAPI.SearchHistoryAnalyticsProvider {
  public func trackHistoryItemSelected()
}
extension PRAPI.NTFFeed {
  public var isEmpty: Swift.Bool {
    get
  }
}
@_inheritsConvenienceInitializers @_hasMissingDesignatedInitializers @objc public class ScreenViewAnalytics : PRAPI.Analytics {
  @objc deinit
}
@objc extension PRAPI.PRMyLibraryItem {
  @objc dynamic public var isExpired: Swift.Bool {
    @objc get
  }
}
@objc @_inheritsConvenienceInitializers final public class OAuth2Manager : ObjectiveC.NSObject {
  @objc public static var shared: (any PRAPI.PROAuth2)? {
    @objc get
  }
  @objc override dynamic public init()
  @objc deinit
}
extension PRAPI.NTFPersonalizationItem {
  final public class func fetchRequest() -> CoreData.NSFetchRequest<PRAPI.NTFDataItem>
}
@_inheritsConvenienceInitializers @_hasMissingDesignatedInitializers @objc final public class FirebaseAnalytics : PRAPI.ScreenViewAnalytics {
  @objc override final public class var isEnabled: Swift.Bool {
    @objc get
  }
  @objc deinit
}
extension PRAPI.Interest {
  public class func interest(with json: [Swift.String : Any], session: PRAPI.NTFSession) -> PRAPI.Interest?
  public class func interest(with id: Swift.Int, name: Swift.String, subtitle: Swift.String? = nil, imageId: Swift.String? = nil, selected: Swift.Bool = false, session: PRAPI.NTFSession) -> PRAPI.Interest
}
extension PRAPI.PRGoogleSignInManager : PRAPI.SignInManagerProtocol {
  public typealias ResultType = PRAPI.GoogleSignInResult
  public static var shared: Self {
    get
  }
}
extension Foundation.NSNotification.Name {
  public static let hotSpotStatusUpdated: Foundation.Notification.Name
}
@objc extension Foundation.NSNotification {
  @objc public static let hotSpotStatusUpdated: Foundation.Notification.Name
}
extension PRAPI.HotSpotManager {
  public struct NotificationSendingInfo : Swift.Codable {
    public func encode(to encoder: any Swift.Encoder) throws
    public init(from decoder: any Swift.Decoder) throws
  }
  final public func postStatusUpdatedNotification()
  final public func notifyAboutHotSpotEntering(_ hotSpot: PRAPI.GeoFencingHotSpot)
  @objc final public func notifyAboutHotSpotEntering(message: Swift.String, hotSpotId: Swift.String, isDebug: Swift.Bool)
  final public func notifyAboutHotSpotLeaving(_ hotSpot: PRAPI.GeoFencingHotSpot)
}
extension PRAPI.NTFArticleItem {
  public func fullContent(language: Swift.String) -> PRAPI.DataItemContent?
  public func fullContentPayload(language: Swift.String) -> PRUtils.NSDictionaryCIWrapper?
}
@objc extension PRAPI.PRSourceList {
  @objc dynamic public var types: [any PRAPI.CatalogNavigation] {
    @objc get
  }
}
extension PRAPI.Interest {
  public typealias ReturnType = PRAPI.Interest
  @discardableResult
  public class func getRecommendedInterests() -> PRPromiseKit.Promise
  @discardableResult
  public class func getRecommendedInterests(with displayedInterests: [Swift.Int]?) -> PRPromiseKit.Promise
  @discardableResult
  public class func getRecommendedInterests(with displayedInterests: [Swift.Int]?, selectedInterests: [Swift.Int]?) -> PRPromiseKit.Promise
  public class func searchForInterests(with query: Swift.String, offset: Swift.Int?, completion: @escaping ([PRAPI.Interest.ReturnType]?, (any Swift.Error)?) -> ())
  @discardableResult
  public class func getUserInterests(token: Swift.String? = nil) -> PRPromiseKit.Promise
  @discardableResult
  public class func replaceUserInterests(with interests: [PRAPI.Interest]) -> PRPromiseKit.Promise
  public class func mergeUserInterests()
  public func follow(_ follow: Swift.Bool)
}
public protocol CatalogViewAnalyticsProvider : PRAnalytics.AnalyticsProvider {
  var catalogPath: Swift.String { get }
}
extension PRAPI.CatalogViewAnalyticsProvider {
  public func trackCatalogView()
}
@objc extension PRAPI.PRMyLibraryItem {
  @objc dynamic public var printing: (any PRAPI.PrintableItem)? {
    @objc get
  }
}
@_inheritsConvenienceInitializers final public class PublicationSectionDataSource : PRAPI.CatalogSectionDataSource {
  override public init?(entity: PRCatalogModel.CatalogEntity)
  @objc deinit
}
extension PRAPI.PublicationSectionDataSource : PRAPI.SectionDataSourceProtocol {
  @objc final public var section: PRConfiguration.PRCatalogSectionType {
    @objc get
  }
}
extension PRAPI.PRSourceList : PRAPI.CatalogFacade {
}
@objc extension PRAPI.PRSourceList : PRAPI.ObservableCatalogFacade {
  @objc dynamic public var loadedPublications: [any PRAPI.PRCatalogItem]? {
    @objc get
  }
  @objc dynamic public var navigationFilters: [any PRAPI.CatalogNavigation] {
    @objc get
  }
  @objc dynamic public var categories: [any PRAPI.CatalogNavigationVariant]? {
    @objc get
  }
  @objc dynamic public var countries: [any PRAPI.CountryNavigationVariant]? {
    @objc get
  }
}
@objc @_inheritsConvenienceInitializers public class XCFCompatibilityResolver : ObjectiveC.NSObject {
  @objc public class func mergeUserInterests()
  @objc public class func interest(with json: [Swift.String : Any], session: PRAPI.NTFSession) -> PRAPI.Interest?
  @objc override dynamic public init()
  @objc deinit
}
@objc public protocol NTFActionConfig {
  @objc var generalActionConfig: [Swift.AnyHashable : Any] { get }
  @objc var articleActionConfig: [Swift.AnyHashable : Any] { get }
}
@objc public protocol FlowArticle : PRAPI.NTFActionConfig, PRAPI.NTFArticle, PRAPI.NTFItem {
}
@objc @_Concurrency.MainActor public class BookSubservice : ObjectiveC.NSObject, PRAPI.Preloadable {
  @_Concurrency.MainActor public init?(bookService: PRAPI.BookService)
  @_Concurrency.MainActor public var preloadTask: _Concurrency.Task<(), Swift.Never>?
  @_Concurrency.MainActor public func preload() async
  @objc deinit
}
public protocol LoadableModel : ObjectiveC.NSObjectProtocol {
  var state: PRAPI.ModelState { get set }
  func finishLoading(_ result: PRUtils.VoidResult)
}
public protocol LoadableModelObserver : ObjectiveC.NSObjectProtocol {
  func modelDidFinishLoading(model: any PRAPI.ObservableModel, result: PRUtils.VoidResult)
}
public protocol ObservableModel : PRAPI.LoadableModel, PRAPI.LoadableModelObserver {
  func load() async throws
  func addObserver(_ observer: any PRAPI.LoadableModelObserver)
  func removeObserver(_ observer: (any PRAPI.LoadableModelObserver)?)
  func triggerObservers(_ action: @escaping (any PRAPI.LoadableModelObserver) -> ())
}
public enum ObservableModelError : Swift.Error {
  case failLoading
  public static func == (a: PRAPI.ObservableModelError, b: PRAPI.ObservableModelError) -> Swift.Bool
  public func hash(into hasher: inout Swift.Hasher)
  public var hashValue: Swift.Int {
    get
  }
}
extension PRAPI.ObservableModel {
  public var observers: [PRAPI.PRWeakLink<Swift.AnyObject>] {
    get
    set
  }
  public func removeObserver(_ observer: (any PRAPI.LoadableModelObserver)?)
  public func addObserver(_ observer: any PRAPI.LoadableModelObserver)
  public func triggerObservers(_ action: @escaping (any PRAPI.LoadableModelObserver) -> ())
  public func forEachObserver(_ action: (any PRAPI.LoadableModelObserver) -> Swift.Bool)
  public func _triggerObservers(_ action: @escaping (any PRAPI.LoadableModelObserver) -> ())
  public func _removeObserver(_ observer: (any PRAPI.LoadableModelObserver)?)
  public func _addObserver(_ observer: any PRAPI.LoadableModelObserver)
}
extension PRAPI.ObservableModel {
  public var state: PRAPI.ModelState {
    get
    set
  }
  public func finishLoading(_ result: PRUtils.VoidResult)
}
extension PRAPI.ObservableModel {
  public func load() async throws
}
extension PRAPI.ObservableModel {
  public func modelDidFinishLoading(model: any PRAPI.ObservableModel, result: PRUtils.VoidResult)
}
@objc extension PRAPI.PRCountableValue : PRAPI.CatalogNavigationVariant {
  @objc dynamic public var categoryId: Swift.Int {
    @objc get
  }
  @objc dynamic public var localizedName: Swift.String? {
    @objc get
  }
}
extension PRAPI.PRCountableCountry : PRAPI.CountryNavigationVariant {
  @objc dynamic public var iso: Swift.String {
    @objc get
  }
}
@objc extension PRAPI.PRAccountManager {
  @objc dynamic public var authorizationManager: PRAPI.AuthorizationManager? {
    @objc get
  }
}
@objc public protocol BEHomeAnalyticsProvider : PRAnalytics.AnalyticsProvider {
}
extension PRAPI.BEHomeAnalyticsProvider {
  public func trackHomeLatestIssuesDisclosure()
  public func trackHomeHamburger()
}
extension Foundation.FileManager {
  public enum FileError : Swift.Error {
    case doesNotExist
    case attributesUnavailable
    case incorrectSize(Swift.String)
  }
  public static func validateFile(path: Swift.String, size: Swift.UInt64) -> Swift.Result<Swift.Bool, Foundation.FileManager.FileError>
}
@objc @_inheritsConvenienceInitializers @_hasMissingDesignatedInitializers public class EventAnalytics : PRAPI.Analytics {
  @objc deinit
}
extension PRAPI.NTFArticleItem : PRAPI.NTFItem {
}
extension PRAPI.NTFSession {
  public func publication(cid: PRAPI.CID, context: CoreData.NSManagedObjectContext) -> PRAPI.Publication
}
public protocol NavigableCatalogService {
  var canBatchResponseContainNavigationInfo: Swift.Bool { get }
  func loadFilters(scope: PRCatalogModel.CatalogEntity?) async throws -> [PRCatalogModel.CatalogFilter]
  func processNavigationInfo(_ json: [Swift.String : Any], scope: PRCatalogModel.CatalogEntity?) throws -> [PRCatalogModel.CatalogFilter]
}
extension PRAPI.NavigableCatalogService {
  public var canBatchResponseContainNavigationInfo: Swift.Bool {
    get
  }
}
public struct Background {
  public let colors: [UIKit.UIColor]
  public let angle: Swift.Int
}
extension PRAPI.Background : Swift.Codable {
  public init(from decoder: any Swift.Decoder) throws
  public func encode(to encoder: any Swift.Encoder) throws
}
@objc @objcMembers final public class HotSpotTitles : ObjectiveC.NSObject, Swift.Codable {
  @objc final public let boughtBy: Swift.String?
  @objc final public let complimentaryAccess: Swift.String?
  @objc final public let featuredCarouselTitle: Swift.String?
  @objc final public let sponsorBy: Swift.String?
  @objc deinit
  final public func encode(to encoder: any Swift.Encoder) throws
  public init(from decoder: any Swift.Decoder) throws
}
public protocol BookOrderAnalyticsProvider : PRAPI.BookAnalyticsProvider {
}
extension PRAPI.BookOrderAnalyticsProvider {
  public func trackBookOrderViewOpen()
}
@_inheritsConvenienceInitializers @_hasMissingDesignatedInitializers @objc final public class TreasureDataAnalytics : PRAPI.DictionaryAnalytics {
  @objc override public static var isEnabled: Swift.Bool {
    @objc get
  }
  @objc deinit
}
public enum SearchAnalyticsTab {
  case publications, interests, stories, books
  public static func == (a: PRAPI.SearchAnalyticsTab, b: PRAPI.SearchAnalyticsTab) -> Swift.Bool
  public func hash(into hasher: inout Swift.Hasher)
  public var hashValue: Swift.Int {
    get
  }
}
public protocol SearchAnalyticsProvider : PRAnalytics.AnalyticsProvider {
  var analyticsTrackTab: PRAPI.SearchAnalyticsTab? { get }
}
extension PRAPI.SearchAnalyticsProvider {
  public func trackSearchPresented()
  public func trackSearchDismissed()
  public func trackItemSelected(_ item: Any?, isAllTab: Swift.Bool)
  public func trackSearchSeeAllTap()
  public func trackSearchTabSelected()
}
@objc public protocol CatalogItemDataSourceProtocol : PRAPI.LoadableDataSource, PRAPI.SectionalDataSource, PRAPI.SilentDataLoader {
  @objc var dataProvider: [[any PRAPI.PRCatalogItem]] { get }
  @objc var itemToExclude: (any PRAPI.PRCatalogItem)? { get set }
  @objc func layoutType(for section: Swift.Int) -> PRAPI.PRLayoutType
  @objc func showDatesOnly(for section: Swift.Int) -> Swift.Bool
}
@_inheritsConvenienceInitializers open class CatalogItemDataSource : PRAPI.DataSource<any PRAPI.PRCatalogItem>, PRAPI.CatalogItemDataSourceProtocol {
  @objc public var dataProvider: [[any PRAPI.PRCatalogItem]] {
    @objc get
  }
  @objc open var itemToExclude: (any PRAPI.PRCatalogItem)?
  @objc override public var isEmpty: Swift.Bool {
    @objc get
  }
  @objc override public func numberOfItems(in section: Swift.Int) -> Swift.Int
  @objc open func layoutType(for section: Swift.Int) -> PRAPI.PRLayoutType
  @objc open func showDatesOnly(for section: Swift.Int) -> Swift.Bool
  @objc required dynamic public init()
  override public init(observer: (any PRAPI.DataSourceObserver)? = nil)
  @objc deinit
}
@objc public protocol SplashScreenAnalyticsProvider : PRAnalytics.AnalyticsProvider {
}
extension PRAPI.SplashScreenAnalyticsProvider {
  public func trackSplashScreen()
}
@available(*, unavailable)
@objc extension PRAPI.PRCoreDataController {
  @objc dynamic public func registerValueTransformers()
}
@objc extension UIKit.UIAlertController {
  @objc @_Concurrency.MainActor @preconcurrency dynamic public var presentationContext: PRAPI.PRAlertControllerPresentationContext {
    @objc get
    @objc set
  }
}
@objc extension PRCatalogModel.Book {
  @objc final public var needsUpdatedDetails: Swift.Bool {
    @objc get
  }
  @objc override final public func downloadState(options: PRCatalogModel.CatalogItemContentOption = []) -> PRAPI.PRTitleItemExemplarState
}
@objc @_hasMissingDesignatedInitializers final public class CatalogPresenter : ObjectiveC.NSObject {
  @objc deinit
}
extension PRAPI.CatalogPresenter : PRAPI.ObservableCatalogFacade {
  @objc final public var isEmpty: Swift.Bool {
    @objc get
  }
  @objc final public var loadedPublications: [any PRAPI.PRCatalogItem]? {
    @objc get
  }
  @objc final public var navigationFilters: [any PRAPI.CatalogNavigation] {
    @objc get
  }
  @objc final public var categories: [any PRAPI.CatalogNavigationVariant]? {
    @objc get
  }
  @objc final public var countries: [any PRAPI.CountryNavigationVariant]? {
    @objc get
  }
}
@objc @_inheritsConvenienceInitializers @objcMembers final public class ExternalAuthURLManager : ObjectiveC.NSObject {
  @objc public static var returnURL: Swift.String {
    @objc get
  }
  @objc public static func url(provider: Swift.String, extKey: Swift.String, onlineToken: Swift.String, authType: Swift.String = "signup", linkToCurrentAccount: Swift.Bool = false, command: Swift.String? = nil) -> Foundation.URL?
  @objc public static func url(provider: Swift.String, extKey: Swift.String, onlineToken: Swift.String, authType: Swift.String = "signup", linkToCurrentAccount: Swift.Bool = false, command: Swift.String? = nil, returnURLAction: Swift.String? = nil) -> Foundation.URL?
  public static func info(url: Foundation.URL) -> (success: Swift.Bool, isNewUser: Swift.Bool, error: (any Swift.Error)?)
  @objc public static func isReturnURL(_ url: Foundation.URL) -> Swift.Bool
  @objc public static func error(url: Foundation.URL) -> (any Swift.Error)?
  @objc public static func error(params: [Swift.AnyHashable : Any]) -> (any Swift.Error)?
  @objc public static func isNewUser(url: Foundation.URL) -> Swift.Bool
  @objc public static func isNewUser(params: [Swift.AnyHashable : Any]) -> Swift.Bool
  @objc override dynamic public init()
  @objc deinit
}
public struct GeoFencingHotSpot : Swift.Identifiable, Swift.Hashable, Swift.Codable {
  public let id: Swift.String
  public let location: CoreLocation.CLLocation
  public let radius: CoreLocation.CLLocationDistance
  public let url: Foundation.URL?
  public let title: Swift.String?
  public let description: Swift.String?
  public let address: Swift.String?
  public let isEnabled: Swift.Bool
  public let isRestricted: Swift.Bool
  public let priority: Swift.Int
  public static func == (left: PRAPI.GeoFencingHotSpot, right: PRAPI.GeoFencingHotSpot) -> Swift.Bool
  public func hash(into hasher: inout Swift.Hasher)
  public init(from decoder: any Swift.Decoder) throws
  public func encode(to encoder: any Swift.Encoder) throws
  public typealias ID = Swift.String
  public var hashValue: Swift.Int {
    get
  }
}
@objc public protocol DataSourceObserver {
  @objc optional func startDataLoading(_ source: Any)
  @objc func completeDataLoading(_ source: Any)
  @objc optional func dataSourceDidChange(_ source: Any)
}
@objc public protocol LoadableDataSource : ObjectiveC.NSObjectProtocol {
  @objc var loadingError: (any Swift.Error)? { get }
  @objc var canLoadMore: Swift.Bool { get }
  @objc var isEmpty: Swift.Bool { get }
  @objc var isLoading: Swift.Bool { get }
  @objc var isFailed: Swift.Bool { get }
  @objc @discardableResult
  func load() -> Swift.Bool
  @objc @discardableResult
  func loadMore() -> Swift.Bool
  @objc func addObserver(_ observer: any PRAPI.DataSourceObserver)
  @objc func removeObserver(_ observer: any PRAPI.DataSourceObserver)
}
@objc public protocol SilentDataLoader : ObjectiveC.NSObjectProtocol {
  @objc var canLoadMoreSilently: Swift.Bool { get }
}
@objc public protocol SectionalDataSource : ObjectiveC.NSObjectProtocol {
  @objc func numberOfItems(in section: Swift.Int) -> Swift.Int
  @objc func numberOfSections() -> Swift.Int
  @objc func title(for section: Swift.Int) -> Swift.String?
}
public enum DataSourceState {
  case unloaded
  case loading
  case loaded
  case failed
  public static func == (a: PRAPI.DataSourceState, b: PRAPI.DataSourceState) -> Swift.Bool
  public func hash(into hasher: inout Swift.Hasher)
  public var hashValue: Swift.Int {
    get
  }
}
public enum DataSourceLoadingType {
  case append
  case discard
  public static func == (a: PRAPI.DataSourceLoadingType, b: PRAPI.DataSourceLoadingType) -> Swift.Bool
  public func hash(into hasher: inout Swift.Hasher)
  public var hashValue: Swift.Int {
    get
  }
}
@_inheritsConvenienceInitializers open class DataSource<AnItem> : PRAPI.PRObservableObject<any PRAPI.DataSourceObserver>, PRAPI.LoadableDataSource, PRAPI.SectionalDataSource, PRAPI.SilentDataLoader {
  open var items: [Swift.Int : [AnItem]] {
    get
  }
  @objc public var loadingError: (any Swift.Error)? {
    get
  }
  @objc open var canLoadMore: Swift.Bool {
    get
  }
  open var loadingType: PRAPI.DataSourceLoadingType {
    get
  }
  @objc open var isEmpty: Swift.Bool {
    @objc get
  }
  @objc open var isLoading: Swift.Bool {
    @objc get
  }
  @objc public var isFailed: Swift.Bool {
    @objc get
  }
  public var state: PRAPI.DataSourceState {
    get
  }
  @objc required override dynamic public init()
  public init(observer: (any PRAPI.DataSourceObserver)? = nil)
  public func item(at indexPath: Foundation.IndexPath) -> AnItem?
  open func indexPath(of item: AnItem) -> Foundation.IndexPath?
  @objc open func numberOfItems(in section: Swift.Int) -> Swift.Int
  @objc public func numberOfSections() -> Swift.Int
  @objc open func title(for section: Swift.Int) -> Swift.String?
  open func subtitle(for section: Swift.Int) -> Swift.String?
  public func fill(with items: [Swift.Int : [AnItem]])
  public func removeItem(at indexPath: Foundation.IndexPath)
  public func insertItem(_ item: AnItem, at indexPath: Foundation.IndexPath)
  public func appendItem(_ item: AnItem, for section: Swift.Int)
  @discardableResult
  @objc open func load() -> Swift.Bool
  @discardableResult
  open func load(forced: Swift.Bool) -> Swift.Bool
  @discardableResult
  @objc open func loadMore() -> Swift.Bool
  public func allItems() -> [AnItem]
  open func startLoading()
  public func completeLoading(result: [AnItem]?, error: (any Swift.Error)?, notify: Swift.Bool = true)
  public func completeLoading(sections: [Swift.Int : [AnItem]]?, error: (any Swift.Error)?, notify: Swift.Bool = true)
  public func completeLoading(result: [AnItem]?, state: PRAPI.DataSourceState, notify: Swift.Bool = true)
  public func completeLoading(sections: [Swift.Int : [AnItem]]?, state: PRAPI.DataSourceState, notify: Swift.Bool = true)
  public func notifyOfChanges()
  @objc final public var canLoadMoreSilently: Swift.Bool {
    @objc get
  }
  @objc deinit
}
extension PRAPI.PRAccountItem {
  @objc dynamic public func activeSubscriptionBundles() -> [PRAPI.PRSubscriptionBundle]?
  public func backIssueStartDate(productId: Swift.String) -> Foundation.Date?
  @objc dynamic public func inferiorActiveBundles(productId: Swift.String) -> [PRAPI.PRUserBundle]
}
@_inheritsConvenienceInitializers @objc(NTFPersonalizationItem) final public class NTFPersonalizationItem : PRAPI.NTFFeedItem {
  final public var onboardingStatus: PRAPI.PROnboardingStatus {
    get
  }
  @objc override final public var type: PRAPI.NTFDataItemType {
    @objc get
  }
  @objc override dynamic public init(entity: CoreData.NSEntityDescription, insertInto context: CoreData.NSManagedObjectContext?)
  @objc deinit
}
extension PRAPI.PRLatestIssuesList {
  @objc override dynamic public var presentationOptions: PRAPI.CatalogPresentationOption {
    @objc get
    @objc set
  }
}
public protocol BookAnalyticsProvider : PRAnalytics.AnalyticsProvider {
  var book: PRCatalogModel.Book { get }
}
extension PRConfiguration.PROnboardingConfig {
  @objc dynamic public var isActive: Swift.Bool {
    @objc get
  }
}
@objc public protocol PrintableItem {
  @objc var isPrintingEnabled: Swift.Bool { get }
  @objc var isPagePrintingEnabled: Swift.Bool { get }
  @objc var isArticlePrintingEnabled: Swift.Bool { get }
  @objc var isArticlePrintInGraphicEnabled: Swift.Bool { get }
  @objc var isIssuePrintingEnabled: Swift.Bool { get }
  @objc var printedPages: Swift.Set<Swift.Int> { get set }
  @objc func isPrintingAllowedForPage(_ page: Swift.Int) -> Swift.Bool
  @objc func recordIssuePrinted()
}
@objc public protocol ReadingViewItem : PRAPI._ReadingViewItem {
  @objc var printing: (any PRAPI.PrintableItem)? { get }
  @objc(isEqualToItem:) func isEqual(_ item: any PRAPI.ReadingViewItem) -> Swift.Bool
}
extension PRAPI.NTFSession {
  public func updatePublicationChannels(_ completion: @escaping ([PRAPI.PublicationChannel]) -> Swift.Void)
}
@_Concurrency.MainActor public class MOService<T, Controller> : ObjectiveC.NSObject where T : CoreData.NSManagedObject, Controller : PRAPI.PRCoreDataController {
  nonisolated final public let mainContext: CoreData.NSManagedObjectContext
  nonisolated final public let privateContext: CoreData.NSManagedObjectContext
  @_Concurrency.MainActor public var item: T? {
    get
  }
  nonisolated public init(item: T)
  @objc deinit
}
public struct BookReadingEvent : Swift.Encodable {
  public func encode(to encoder: any Swift.Encoder) throws
}
extension PRAPI.BookReadingEvent {
  public init(epub: PRAPI.EpubContent, contentLength: Swift.Int, frames: [PRAPI.BookReadingFrame])
}
@objc @_inheritsConvenienceInitializers @_hasMissingDesignatedInitializers final public class Auth0Manager : ObjectiveC.NSObject {
  @objc public static var shared: PRAPI.Auth0Manager {
    @objc get
  }
  @objc public static var isEnabled: Swift.Bool {
    @objc get
  }
  @objc final public func signIn(_ completion: @escaping (Swift.Bool, (any Swift.Error)?) -> ())
  final public func syncToken()
  @objc deinit
}
@objc extension PRCatalogModel.BookContent : PRAPI.DeviceTimeTweakProtected {
}
extension PRAPI.PRCollectionsModel {
  @objc dynamic public func loadFromCache() -> [PRAPI.NTFCollectionItem]?
}
extension PRAPI.PRMyLibrary {
  public var catalogItems: [any PRAPI.PRCatalogItem] {
    get
  }
  @objc dynamic public func getCatalogItems(order: PRConfiguration.PRCatalogSortingOrder = .notDefined) -> [any PRAPI.PRCatalogItem]
  public func delete(_ item: any PRAPI.PRCatalogItem)
  public func deleteAll()
}
extension PRAPI.PRMyLibrary : PRUtils.Observable {
  public typealias Callback = () -> Swift.Void
}
@objc extension PRAPI.PRMyLibrary {
  @objc dynamic public func observeItems()
}
@objc extension PRCatalogModel.Document : PRAPI.ReadingViewItem {
  @objc dynamic public var printing: (any PRAPI.PrintableItem)? {
    @objc get
  }
  @objc override dynamic public func done() -> Swift.Bool
  @objc dynamic public func pdnDone() -> Swift.Bool
  @objc dynamic public func pdnDownloaded(forPage pageNumber: Swift.UInt) -> Swift.Bool
  @objc dynamic public func getPage(_ pageNumber: Swift.UInt) -> PRAPI.PRPage?
  @objc dynamic public func saveToPersistentStore()
  @objc dynamic public func encryptionKey() -> Swift.String
  @objc dynamic public func progress() -> Foundation.Progress?
  @objc dynamic public func pdnProgress() -> Foundation.Progress?
  @objc dynamic public func pdnProgress(forPage page: Swift.UInt) -> Foundation.Progress?
  @objc dynamic public func pdfDoc() -> PRAPI.PDFDoc?
  @objc dynamic public func pdfDoc(forPage pageNo: Swift.UInt) -> PRAPI.PDFDoc?
  @objc dynamic public func pdfDoc(forPage pageNo: Swift.UInt, loadPdfIfNotAvailable: Swift.Bool) throws -> PRAPI.PDFDoc
  @objc dynamic public func paperColor() -> UIKit.UIColor
  @objc dynamic public func printingAsBitmap() -> Swift.Bool
  @objc dynamic public func defaultImagePath(forPage page: Swift.UInt) -> Swift.String
  @objc dynamic public func imagePath(forPage page: Swift.UInt, width: CoreFoundation.CGFloat, useDefaultIfNotExist useDefault: Swift.Bool) -> Swift.String?
  @objc dynamic public func imagePath(forPage page: Swift.UInt, width: CoreFoundation.CGFloat, defaultIfNotExist pUseDefault: Swift.UnsafeMutablePointer<ObjectiveC.ObjCBool>) -> Swift.String?
  @objc dynamic public func fgImagePath(forPath path: Swift.String) -> Swift.String
  @objc dynamic public func image(fromPdfPage pageNo: Swift.UInt, pdfRect: CoreFoundation.CGRect, imageSize: CoreFoundation.CGSize, contentScaleFactor contentScale: CoreFoundation.CGFloat) throws -> UIKit.UIImage
}
@objc extension PRCatalogModel.Document : PRAPI.PRSmartLayoutItem {
  @objc dynamic public var isSmartDone: Swift.Bool {
    @objc get
  }
  @objc dynamic public var isSmartUpdated: Swift.Bool {
    @objc get
  }
  @objc dynamic public var smart: PRSmart.PRSmartObject? {
    @objc get
  }
  @objc dynamic public var processedSmart: PRSmart.PRSmartObject? {
    @objc get
  }
  @objc dynamic public func processSmart()
}
public struct BookReadingFrame : Swift.Encodable {
  public func encode(to encoder: any Swift.Encoder) throws
}
extension PRAPI.BookReadingFrame {
  public init(startTime: Foundation.Date, endTime: Foundation.Date, fragments: [PRAPI.BookReadingFragment])
}
extension PRAPI.BookService : PRAPI.NavigableCatalogService {
  @_Concurrency.MainActor final public var canBatchResponseContainNavigationInfo: Swift.Bool {
    get
  }
  @_Concurrency.MainActor final public func loadFilters(scope: PRCatalogModel.CatalogEntity?) async throws -> [PRCatalogModel.CatalogFilter]
  @_Concurrency.MainActor final public func processNavigationInfo(_ json: [Swift.String : Any], scope: PRCatalogModel.CatalogEntity?) throws -> [PRCatalogModel.CatalogFilter]
}
@objc extension PRAPI.NTFAbstractArticle {
  @objc dynamic public var isTranslatable: Swift.Bool {
    @objc get
  }
  @objc dynamic public var url: Foundation.URL? {
    @objc get
  }
}
extension Foundation.NSNotification.Name {
  public static let bookLicensesUpdated: Foundation.Notification.Name
}
@objc extension Foundation.NSNotification {
  @objc public static let bookLicensesUpdated: Foundation.Notification.Name
}
@objc public enum BookLicenseUpdateStatus : Swift.Int {
  case added, deleted
  public init?(rawValue: Swift.Int)
  public typealias RawValue = Swift.Int
  public var rawValue: Swift.Int {
    get
  }
}
@objc @_inheritsConvenienceInitializers @_Concurrency.MainActor final public class BookLicenseService : PRAPI.BookSubservice {
  @_Concurrency.MainActor override public init?(bookService: PRAPI.BookService)
  @_Concurrency.MainActor final public func loadEffectiveLicenses() async throws
  @discardableResult
  @_Concurrency.MainActor final public func loadEffectiveLicense(bookId id: Swift.String) async throws -> PRCatalogModel.BookLicense?
  @_Concurrency.MainActor final public func renewLicense(bookId: Swift.String) async throws -> PRAPI.BookLicenseRenewResult
  @_Concurrency.MainActor final public func loadLicenseProducts(bookPRN prn: Swift.String) async throws -> [PRAPI.BookLicenseProduct]
  @_Concurrency.MainActor final public func checkoutFreeProduct(_ product: PRAPI.BookLicenseProduct) async throws -> PRAPI.BookLicenseCheckoutResult
  @_Concurrency.MainActor override final public func preload() async
  @objc deinit
}
extension PRAPI.BookLicenseService : PRAPI.BookPurchaseAnalyticsProvider {
}
@objc extension PRAPI.PRCollectionsModel {
  @objc dynamic public var channel: PRAPI.Channel? {
    @objc get
  }
}
@objc extension PRAPI.NTFCollectionItem {
  @objc public static func collections(with info: [[Swift.String : Any]], channelId: Swift.String) -> [PRAPI.NTFCollectionItem]
  @objc public static func collection(with info: [Swift.String : Any], channelId: Swift.String, forceUpdate: Swift.Bool = false) -> PRAPI.NTFCollectionItem?
  @objc dynamic public func update(with info: [Swift.String : Any])
}
@objc extension PRAPI.PRCatalogFilterItem {
  @objc dynamic public var sourceListFilterId: PRAPI.CatalogNavigationType {
    @objc get
    @objc set
  }
  @objc dynamic public func filter(id: PRAPI.CatalogNavigationType) -> PRAPI.PRSourceListFilter?
}
@objc extension PRAPI.PRCatalogFilterItem : PRAPI.CatalogNavigation {
  @objc dynamic public var options: [PRAPI.CatalogNavigationSection] {
    @objc get
  }
  @objc dynamic public var name: Swift.String {
    @objc get
  }
  @objc dynamic public var type: PRAPI.CatalogNavigationType {
    @objc get
  }
  @objc dynamic public var value: Any? {
    @objc get
  }
  @objc dynamic public var catalogType: PRAPI.CatalogType {
    @objc get
  }
}
extension PRAPI.PRTitleItem {
  public class func getRecommendedCIDs(with displayedCIDs: [Swift.String]?, selectedCIDs: [Swift.String]?, selectedInterests: [PRAPI.Interest]?) -> PRPromiseKit.Promise
}
public protocol AutoTranslationPromtAnalyticsProvider : PRAnalytics.AnalyticsProvider {
}
extension PRAPI.AutoTranslationPromtAnalyticsProvider {
  public func trackAutoTranslationPromtAction(_ action: PRAnalytics.PRAnalyticsAutoTranslationPopUpAction)
}
@objc @_inheritsConvenienceInitializers final public class ListenHighlightsModel : ObjectiveC.NSObject {
  final public var isReady: Swift.Bool {
    get
  }
  final public var data: [PRAPI.NTFArticleItem]? {
    get
  }
  @objc override dynamic public init()
  @objc deinit
}
extension PRAPI.ListenHighlightsModel : PRAPI.ObservableModel {
  @_Concurrency.MainActor final public func load() async throws
}
extension PRAPI.ListenHighlightsModel : CoreData.NSFetchedResultsControllerDelegate {
  @objc final public func controllerDidChangeContent(_ controller: CoreData.NSFetchedResultsController<any CoreData.NSFetchRequestResult>)
}
@objc extension PRAPI.PRCatalogFilter {
  @objc dynamic public func filter(id: PRAPI.CatalogNavigationType) -> PRAPI.PRSourceListFilter?
}
extension PRAPI.PRFacebookSignInManager : PRAPI.SignInManagerProtocol {
  public typealias ResultType = PRAPI.FacebookSignInResult
  public static var shared: Self {
    get
  }
}
extension PRCatalogModel.PressCatalog {
  final public class func getCatalog(context: CoreData.NSManagedObjectContext) -> PRCatalogModel.PressCatalog
}
@objc extension PRCatalogModel.Document {
  @objc override dynamic public class func loadItem(id: Swift.String, catalog: PRCatalogModel.Catalog, context: CoreData.NSManagedObjectContext) -> PRPromiseKit.Promise
}
extension PRAPI.PRSourceItem {
  @discardableResult
  public func loadMastheadInfo() -> PRPromiseKit.Promise
}
extension PRAPI.PRSourceItem : PRAPI.MastheadProvider {
  @objc dynamic public var hasMasthead: Swift.Bool {
    @objc get
  }
  @objc dynamic public func masthead(height: CoreFoundation.CGFloat, style: UIKit.UIUserInterfaceStyle, handler: @escaping PRThumbnail.PRThumbnailHandler)
}
@objc @_hasMissingDesignatedInitializers final public class LocationManager : ObjectiveC.NSObject, PRAPI.BackgroundTaskRunner {
  final public var backgroundTasks: Swift.Set<PRAPI.BackgroundTask>
  @objc deinit
}
extension PRAPI.LocationManager : CoreLocation.CLLocationManagerDelegate {
  @objc final public func locationManagerDidChangeAuthorization(_ manager: CoreLocation.CLLocationManager)
  @objc final public func locationManager(_ manager: CoreLocation.CLLocationManager, didUpdateLocations locations: [CoreLocation.CLLocation])
  @objc final public func locationManager(_ manager: CoreLocation.CLLocationManager, didFailWithError error: any Swift.Error)
  @objc final public func locationManager(_ manager: CoreLocation.CLLocationManager, didStartMonitoringFor region: CoreLocation.CLRegion)
  @objc final public func locationManager(_ manager: CoreLocation.CLLocationManager, didDetermineState state: CoreLocation.CLRegionState, for region: CoreLocation.CLRegion)
  @objc final public func locationManager(_ manager: CoreLocation.CLLocationManager, monitoringDidFailFor region: CoreLocation.CLRegion?, withError error: any Swift.Error)
}
@objc public protocol AccountAnalyticsProvider : PRAnalytics.AnalyticsProvider {
  @objc var accountViewType: PRAnalytics.PRAnalyticsAccountView { get }
}
extension PRAPI.AccountAnalyticsProvider {
  public func trackAccountDidAppear()
  public func trackDeleteAccount(_ success: Swift.Bool)
}
@objc extension PRAPI.PRSubscription {
  @objc dynamic public func requestGoogleAdsConfig(_ completion: @escaping (PRUtils.SPNode?, (any Swift.Error)?) -> ())
}
@objc @_inheritsConvenienceInitializers @_hasMissingDesignatedInitializers final public class SpoorAnalytics : PRAPI.EventAnalytics {
  @objc override public static var isEnabled: Swift.Bool {
    @objc get
  }
  @objc override final public func track(_ name: PRAnalytics.PRAnalyticsTrackName, parameters: PRAnalytics.AnalyticsParameters?)
  @objc deinit
}
@objc @_inheritsConvenienceInitializers @objcMembers final public class DIExtension : ObjectiveC.NSObject {
  @objc @PRDIContainer.Inject final public var analytics: PRAnalytics.PRAnalyticsService? {
    @objc get
  }
  @objc @PRDIContainer.Inject final public var util: PRAPI.PRCoreUtil? {
    @objc get
  }
  @objc @PRDIContainer.Inject final public var options: PRAPI.PROptions? {
    @objc get
  }
  @objc @PRDIContainer.Inject final public var catalog: PRAPI.PRCatalog? {
    @objc get
  }
  @objc @PRDIContainer.Inject final public var library: PRAPI.PRMyLibrary? {
    @objc get
  }
  @objc @PRDIContainer.Inject final public var accountManager: PRAPI.PRAccountManager? {
    @objc get
  }
  @objc @PRDIContainer.Inject final public var hotSpotManager: PRAPI.HotSpotManager? {
    @objc get
  }
  @objc @PRDIContainer.Inject final public var widgetManager: PRAPI.WidgetsManager? {
    @objc get
  }
  @objc override dynamic public init()
  @objc deinit
}
@objc extension ObjectiveC.NSObject {
  @objc public static let pr_inject: PRAPI.DIExtension
  @objc dynamic public var pr_inject: PRAPI.DIExtension {
    @objc get
  }
}
@objc extension PRAPI.PRModel : PRProtocols.Singleton {
  @objc public static func instance() -> Self
  @objc public static func hasInstance() -> Swift.Bool
  @objc public static func dismiss()
}
public protocol PressCatalogable : PRCatalogModel.Catalog {
  associatedtype Service : PRAPI.LoadableCatalog
  var pressCatalog: PRCatalogModel.PressCatalog { get set }
  var service: Self.Service? { get }
}
@objc extension PRAPI.PRCatalog {
  @objc dynamic public var dataController: PRAPI.CatalogCoreDataController {
    @objc get
  }
  @objc dynamic public func updatePressCatalogForced(_ forced: Swift.Bool)
  @objc dynamic public func pressCatalog(context: CoreData.NSManagedObjectContext) -> PRCatalogModel.PressCatalog
  @objc dynamic public func downloads(context: CoreData.NSManagedObjectContext) -> PRCatalogModel.Downloads
}
extension PRAPI.PRAccountManager {
  @objc dynamic public func syncExternalAuthToken()
}
extension PRAPI.Channel {
  public var collectionsCount: Swift.Int {
    get
  }
  public var hasCollections: Swift.Bool {
    get
  }
  public func collection(id: Swift.String, context: CoreData.NSManagedObjectContext) -> PRAPI.NTFCollectionItem
  public func collection(id: Swift.String, context: CoreData.NSManagedObjectContext) -> PRAPI.NTFCollectionItem?
}
@objc @_inheritsConvenienceInitializers final public class WidgetsManager : ObjectiveC.NSObject {
  @objc final public func start()
  final public func reloadWidgets(kind: PRConfiguration.WidgetKind)
  @objc override dynamic public init()
  @objc deinit
}
extension PRAPI.WidgetsManager : PRAnalytics.WidgetsAnalyticsProvider {
  final public func widgetsInfo() async throws -> [WidgetKit.WidgetInfo]
}
extension PRAPI.NTFCoreDataController {
  public func getOnlineSession(in context: CoreData.NSManagedObjectContext, completion: @escaping (PRAPI.NTFSession) -> Swift.Void)
  @objc dynamic public func processOnlineSessionHandlers()
}
extension PRAPI.PRCatalog {
  public func item(cid: Swift.String, date: Foundation.Date? = nil) -> (any PRAPI.PRCatalogItem)?
}
@_inheritsConvenienceInitializers @objc public class BookResponseHandler : ObjectiveC.NSObject {
  public typealias BookResourceDataProviderBlock = (Swift.String) -> Foundation.Data?
  @objc override dynamic public init()
  public static let bookLocalAssetsBaseUrlPath: Swift.String
  @objc public func setupHandler(for server: GCDWebServers.GCDWebServer)
  @objc public func addBook(id: Swift.String, baseFileUrl: Foundation.URL) -> Swift.String?
  @objc public func addBook(id: Swift.String, resourceDataProvider: @escaping PRAPI.BookResponseHandler.BookResourceDataProviderBlock) -> Swift.String?
  @objc public func removeBook(id: Swift.String)
  @objc deinit
}
@objc extension PRAPI.NTFPageSetItem : PRAPI.NTFItem {
  @objc dynamic public var hasMasthead: Swift.Bool {
    @objc get
  }
  @objc dynamic public func masthead(height: CoreFoundation.CGFloat, style: UIKit.UIUserInterfaceStyle, handler: @escaping PRThumbnail.PRThumbnailHandler)
}
@objc extension PRAPI.PRAccountItem {
  @objc dynamic public var isReachableAndReady: Swift.Bool {
    @objc get
  }
  @objc dynamic public var emailPermissionsRequired: Swift.Bool {
    @objc get
  }
}
public protocol BannerAnalyticsProvider : PRAnalytics.AnalyticsProvider {
  var bannerType: PRAnalytics.PRAnalyticsBannerType { get }
  var bannerContext: PRAnalytics.PRAnalyticsBannerContext { get }
}
extension PRAPI.BannerAnalyticsProvider {
  public func trackBannerImpression()
  public func trackBannerAction(_ action: PRAnalytics.PRAnalyticsBannerAction)
}
extension PRAPI.EpubContent {
  public func data(resourcePath: Swift.String) -> Foundation.Data?
}
extension PRAPI.PRCatalog {
  public var publicationService: PRAPI.PublicationService? {
    get
  }
  public var bookService: PRAPI.BookService? {
    get
  }
}
extension PRAPI.Publication {
  public var titleItem: PRAPI.PRTitleItem? {
    get
  }
}
@_inheritsConvenienceInitializers @_hasMissingDesignatedInitializers @objc final public class ComScoreAnalytics : PRAPI.DictionaryAnalytics {
  @objc override final public class var isEnabled: Swift.Bool {
    @objc get
  }
  @objc deinit
}
@objc @objcMembers final public class NTFSocialInfoBookmark : ObjectiveC.NSObject {
  @objc final public let date: Foundation.Date
  @objc final public let labels: [PRAPI.NTFSocialInfoBookmarkLabel]
  @objc final public let userProfile: PRAPI.NTFSocialInfoBookmarkUser
  @objc public init?(info: [Swift.String : Any])
  @objc final public func label(id: Swift.String) -> PRAPI.NTFSocialInfoBookmarkLabel?
  @objc deinit
}
@objc @_hasMissingDesignatedInitializers @objcMembers final public class NTFSocialInfoBookmarkLabel : ObjectiveC.NSObject, Swift.Identifiable {
  @objc final public let id: Swift.String
  @objc final public let customId: Swift.String
  @objc final public let isPublic: Swift.Bool
  @objc final public let rawName: Swift.String
  @objc final public let name: Swift.String
  @objc final public var localizedName: Swift.String {
    @objc get
  }
  public typealias ID = Swift.String
  @objc deinit
}
@objc @_hasMissingDesignatedInitializers @objcMembers final public class NTFSocialInfoBookmarkUser : ObjectiveC.NSObject {
  @objc final public let avatarImageId: Swift.String?
  @objc final public let enAccountNumber: Swift.String?
  @objc final public let followedByCurrentUser: Swift.Int
  @objc final public let nickname: Swift.String?
  @objc final public let photoUrl: Swift.String?
  @objc final public let postsCount: Swift.Int
  @objc final public let profileName: Swift.String?
  @objc deinit
}
extension PRAPI.PRSponsorshipManagerService {
  @objc(PRSponsorshipManagerServiceMethod) public enum Method : Swift.Int {
    case searchHotZoneClusters
    case getGeoFencingHotZoneLocations
    case searchHotZoneLocations
    case searchHotZoneClustersWithBounds
    case setHotzoneStatus
    case getCobranding
    case getNotificationTitles
    public init?(rawValue: Swift.Int)
    public typealias RawValue = Swift.Int
    public var rawValue: Swift.Int {
      get
    }
  }
  @objc dynamic public func updateHotSpotInfo() async
  @available(swift, obsoleted: 1.0)
  @objc dynamic public func updateHotSpotInfo()
  public func getGeoFencingHotZoneLocations(rect: PRAPI.LocationRect) async throws -> [PRAPI.GeoFencingHotSpot]
  @available(*, unavailable)
  @objc @_Concurrency.MainActor dynamic public func request(method: PRAPI.PRSponsorshipManagerService.Method, parameters: [Swift.String : Any]) async throws -> Any
}
public protocol PRBraze {
  var brazeUser: any PRAPI.PRBrazeUser { get }
  var brazeNotifications: any PRAPI.PRBrazeNotifications { get }
  var brazeContentCards: any PRAPI.PRBrazeContentCards { get }
  func logCustomEvent(_ eventName: Swift.String, withProperties properties: [Swift.AnyHashable : Any]?)
  func changeUser(userId: Swift.String, sdkAuthSignature: Swift.String?, fileID: Swift.StaticString, line: Swift.UInt)
}
extension PRAPI.PRBraze {
  public func changeUser(userId: Swift.String)
}
public protocol PRBrazeContentCards {
  var contentCards: [any PRAPI.ContentCard]? { get }
  func subscribeToContentCardUpdates(handler: @escaping ([any PRAPI.ContentCard]) -> Swift.Void) -> any PRAPI.PRBrazeCancellable
}
public protocol PRBrazeUser {
  var userID: Swift.String? { get }
  func subscribeToEmails(_ subscribe: Swift.Bool)
  func set(firstName: Swift.String?)
  func set(lastName: Swift.String?)
  func set(email: Swift.String?, fileID: Swift.StaticString, line: Swift.UInt)
  func setCustomAttribute(key: Swift.String, value: Swift.Bool, fileID: Swift.StaticString, line: Swift.UInt)
  func setCustomAttribute(key: Swift.String, value: Swift.Double, fileID: Swift.StaticString, line: Swift.UInt)
  func setCustomAttribute(key: Swift.String, value: Swift.Int, fileID: Swift.StaticString, line: Swift.UInt)
  func setCustomAttribute(key: Swift.String, value: Swift.String, fileID: Swift.StaticString, line: Swift.UInt)
  func setCustomAttribute(key: Swift.String, value: Foundation.Date, fileID: Swift.StaticString, line: Swift.UInt)
  func setCustomAttribute(key: Swift.String, array: [Swift.String]?, fileID: Swift.StaticString, line: Swift.UInt)
  func unsetCustomAttribute(key: Swift.String, fileID: Swift.StaticString, line: Swift.UInt)
}
extension PRAPI.PRBrazeUser {
  public func set(email: Swift.String?)
  public func setCustomAttribute(key: Swift.String, value: Swift.Bool)
  public func setCustomAttribute(key: Swift.String, value: Swift.Double)
  public func setCustomAttribute(key: Swift.String, value: Swift.Int)
  public func setCustomAttribute(key: Swift.String, value: Swift.String)
  public func setCustomAttribute(key: Swift.String, value: Foundation.Date)
  public func setCustomAttribute(key: Swift.String, array: [Swift.String]?)
  public func unsetCustomAttribute(key: Swift.String)
}
public protocol PRBrazeNotifications {
  func register(deviceToken: Foundation.Data, fileID: Swift.StaticString, line: Swift.UInt)
  func handleBackgroundNotification(userInfo: [Swift.AnyHashable : Any], fetchCompletionHandler completionHandler: @escaping (UIKit.UIBackgroundFetchResult) -> Swift.Void) -> Swift.Bool
  func handleUserNotification(response: UserNotifications.UNNotificationResponse, withCompletionHandler completionHandler: @escaping () -> Swift.Void) -> Swift.Bool
}
extension PRAPI.PRBrazeNotifications {
  public func register(deviceToken: Foundation.Data)
}
public protocol PRBrazeCancellable {
  func cancel()
}
@_inheritsConvenienceInitializers @_Concurrency.MainActor final public class PublicationService : PRAPI.CatalogService<PRCatalogModel.Publications> {
  @_Concurrency.MainActor override final public func preload() async
  override nonisolated public init(item: PRCatalogModel.Publications)
  @objc deinit
}
extension PRAPI.PRSubscription {
  public func saveCoBrandingInfo() throws
  @objc dynamic public func restoreCoBranding() throws
  public func saveHotSpotTitles() throws
  @objc dynamic public func restoreHotSpotTitles() throws
}
extension PRCatalogModel.BookContent {
  public static let PREDICATE_BOOK_CONTENT: Swift.String
  public static let PREDICATE_START_POSITION: Swift.String
  public static let PREDICATE_END_POSITION: Swift.String
  public static let checkIntersectPredicate: Foundation.NSPredicate
  public func bookmarksIntersectingWithLocations(startPosition: Swift.Int, endPosition: Swift.Int) -> [PRCatalogModel.Bookmark]?
  public func removeBookmarks(_ bookmarks: [PRCatalogModel.Bookmark])
  public func removeBookmarks(where shouldBeRemoved: @escaping (PRCatalogModel.Bookmark) -> Swift.Bool)
}
@objc @_inheritsConvenienceInitializers @_hasMissingDesignatedInitializers final public class AppsFlyerAnalytics : PRAPI.Analytics {
  @objc deinit
}
@objc public enum ATTrackingStatus : Swift.UInt {
  case notDetermined = 0
  case restricted
  case denied
  case authorized
  public init?(rawValue: Swift.UInt)
  public typealias RawValue = Swift.UInt
  public var rawValue: Swift.UInt {
    get
  }
}
@objc @_inheritsConvenienceInitializers @objcMembers final public class ATTManager : ObjectiveC.NSObject {
  @objc public static var trackingAuthorizationStatus: PRAPI.ATTrackingStatus {
    @objc get
  }
  @objc public static func requestTrackingAuthorization() async -> PRAPI.ATTrackingStatus
  @objc override dynamic public init()
  @objc deinit
}
extension PRCatalogModel.CatalogItemContent {
  public enum Error : PRUtils.DefaultLocalizedError {
    case unknown
    case noContextAvailable
    case unableToSaveContext
    public static func == (a: PRCatalogModel.CatalogItemContent.Error, b: PRCatalogModel.CatalogItemContent.Error) -> Swift.Bool
    public func hash(into hasher: inout Swift.Hasher)
    public var hashValue: Swift.Int {
      get
    }
  }
  public enum DownloadingError : PRUtils.DefaultLocalizedError {
    case noDestination
    case noServiceUrlProvided
    case unexpectedResponse
    case invalidLicense
    public static func == (a: PRCatalogModel.CatalogItemContent.DownloadingError, b: PRCatalogModel.CatalogItemContent.DownloadingError) -> Swift.Bool
    public func hash(into hasher: inout Swift.Hasher)
    public var hashValue: Swift.Int {
      get
    }
  }
  public func cleanUp() async throws
  public func cleanUpDownloads() async throws
}
@objc extension PRCatalogModel.CatalogItem {
  @objc(isEqualToItem:) dynamic public func isEqual(_ item: any PRAPI.ReadingViewItem) -> Swift.Bool
  @objc dynamic public var isPurchaseAdvise: Swift.Bool {
    @objc get
  }
  @objc dynamic public var viewerPage: Swift.UInt {
    @objc get
    @objc set
  }
  @objc dynamic public var numberOfPages: Swift.UInt {
    @objc get
  }
  @objc dynamic public var pagesCount: Swift.UInt {
    @objc get
  }
  @objc dynamic public func done() -> Swift.Bool
}
extension PRAPI.ArticleLink {
  @objc dynamic public func update(with info: [Swift.String : Any])
}
@objc @objcMembers final public class TextLink : ObjectiveC.NSObject {
  @objc final public let text: Swift.String
  @objc final public let link: Swift.String?
  @objc public init(text: Swift.String, link: Swift.String? = nil)
  @objc final public class var termsOfUse: PRAPI.TextLink? {
    @objc get
  }
  @objc final public class var privacyPolicy: PRAPI.TextLink? {
    @objc get
  }
  @objc final public class var cookiePolicy: PRAPI.TextLink? {
    @objc get
  }
  @objc final public class var policies: [PRAPI.TextLink] {
    @objc get
  }
  @objc final public class var signInPolicies: [PRAPI.TextLink] {
    @objc get
  }
  @objc final public class var privacyAndCookiePolicies: [PRAPI.TextLink] {
    @objc get
  }
  @objc deinit
}
@objc extension PRAPI.PRSourceListFilter {
  @objc dynamic public var filterId: PRAPI.CatalogNavigationType {
    @objc get
    @objc set
  }
  @objc convenience dynamic public init(type: PRAPI.CatalogNavigationType, value: Any?, title: Swift.String?)
}
@objc extension PRAPI.PRAccountItem {
  @objc dynamic public func showDeleteConfirmationAlert(_ completion: @escaping (Swift.Bool) -> ())
}
extension PRAPI.EpubContent {
  public enum LoadingError : PRUtils.DefaultLocalizedError {
    case contentHashDoesNotMatch
    case noManifestFound
    case encryptionInfoParsingError(error: any Swift.Error)
    case unexpected
  }
  public class func load(license: PRAPI.EpubContent.BookLicense) -> PRPromiseKit.Promise
  public func checkHash() -> Swift.Bool
}
extension PRAPI.PublicationChannel {
  public func publicationCIDs() -> [Swift.String]?
}
@_inheritsConvenienceInitializers @objc(PRStreamingOptions) final public class StreamingOptions : ObjectiveC.NSObject {
  @objc final public var streamingURL: Swift.String? {
    @objc get
  }
  @objc final public func streamingURL(articleId: Swift.String, language: Swift.String, originalLanguage: Swift.String, country: Swift.String?, premium: Swift.Bool = false) -> Foundation.URL?
  @objc final public func streamingURL(article: any PRAPI.NTFArticle, premium: Swift.Bool = false) -> Foundation.URL?
  @objc override dynamic public init()
  @objc deinit
}
extension PRAPI.PROptions {
  @objc dynamic public var streaming: PRAPI.StreamingOptions {
    @objc get
  }
}
@objc public protocol IssueAnalyticsProvider : PRAnalytics.AnalyticsProvider {
  @objc var issueDate: Foundation.Date { get }
  @objc var page: Swift.Int { get }
  @objc var pageName: Swift.String? { get }
}
final public class AutoTranslationAnalyticsTracker : PRAPI.AutoTranslationAnalyticsProvider {
  public init(sourceISO: Swift.String, destinationISO: Swift.String, zone: PRAnalytics.PRAnalyticsAutoTranslationZoneType)
  @objc final public let sourceLanguageISOCode: Swift.String
  @objc final public let destinationLanguageISOCode: Swift.String
  @objc final public let translationZone: PRAnalytics.PRAnalyticsAutoTranslationZoneType
  @objc deinit
}
public protocol BackgroundTaskRunner : AnyObject {
  var backgroundTasks: Swift.Set<PRAPI.BackgroundTask> { get set }
}
public struct BackgroundTask : Swift.Hashable, Swift.Identifiable {
  public let id: Foundation.UUID
  public var backgroundTaskId: UIKit.UIBackgroundTaskIdentifier
  public static func == (a: PRAPI.BackgroundTask, b: PRAPI.BackgroundTask) -> Swift.Bool
  public typealias ID = Foundation.UUID
  public func hash(into hasher: inout Swift.Hasher)
  public var hashValue: Swift.Int {
    get
  }
}
extension PRAPI.BackgroundTaskRunner {
  public func beginBackgroundTask() -> PRAPI.BackgroundTask
  public func endBackgroundTask(_ task: PRAPI.BackgroundTask)
  public func runTask(seconds: Foundation.TimeInterval)
}
@objc @objcMembers final public class DeviceActivation : ObjectiveC.NSObject {
  @objc final public let activationNumber: Swift.String
  @objc final public let clientNumber: Swift.String
  @objc final public let userName: Swift.String?
  @objc final public let clientName: Swift.String
  @objc final public let lastActivationDate: Foundation.Date
  @objc final public let createDate: Foundation.Date
  @objc public init?(with node: PRUtils.SPNode, userName: Swift.String?)
  @objc deinit
}
@objc public protocol HotSpotInfo {
  @objc var id: Swift.String { get }
  @objc var name: Swift.String? { get }
  @objc var industry: Swift.String? { get }
}
extension PRAPI.PRMyLibraryItem {
  @objc dynamic public func renewDownloadLicenseIfNeeded(_ completion: ((Swift.Bool) -> ())?)
}
@objc public protocol AutoTranslationAnalyticsProvider : PRAnalytics.AnalyticsProvider {
  @objc var sourceLanguageISOCode: Swift.String { get }
  @objc var destinationLanguageISOCode: Swift.String { get }
  @objc var translationZone: PRAnalytics.PRAnalyticsAutoTranslationZoneType { get }
}
extension PRAPI.AutoTranslationAnalyticsProvider {
  public func trackLanguagePairSave(isSaved: Swift.Bool)
  public func trackLanguagePairRemoved()
  public func trackMLITranslated(_ mli: PRAPI.PRMyLibraryItem)
}
extension PRAPI.Channel {
  public func update(with info: [Swift.String : Any])
}
extension PRCatalogModel.HotSpot : PRAPI.HotSpotInfo {
}
extension PRCatalogModel.HotSpot {
  @objc public static func isActive(account: PRAPI.PRAccountItem) -> Swift.Bool
  public static func object(account: PRAPI.PRAccountItem, context: CoreData.NSManagedObjectContext, forceUpdate: Swift.Bool = true) -> PRCatalogModel.HotSpot?
}
@_inheritsConvenienceInitializers @objc(DataItemContent) public class DataItemContent : CoreData.NSManagedObject {
  @discardableResult
  public class func item(json: [Swift.String : Any], language: Swift.String, dataItem: PRAPI.NTFDataItem, context: CoreData.NSManagedObjectContext) -> PRAPI.DataItemContent
  @objc override dynamic public init(entity: CoreData.NSEntityDescription, insertInto context: CoreData.NSManagedObjectContext?)
  @objc deinit
}
extension PRAPI.DataItemContent {
  @nonobjc public class func fetchRequest() -> CoreData.NSFetchRequest<PRAPI.DataItemContent>
  @objc @NSManaged dynamic public var json: [Swift.String : Any] {
    @objc get
    @objc set
  }
  @objc @NSManaged dynamic public var language: Swift.String {
    @objc get
    @objc set
  }
  @objc @NSManaged dynamic public var item: PRAPI.NTFDataItem {
    @objc get
    @objc set
  }
}
extension PRAPI.DataItemContent : Swift.Identifiable {
  public typealias ID = Swift.ObjectIdentifier
}
@_inheritsConvenienceInitializers @_hasMissingDesignatedInitializers @objc final public class PressReaderAnalytics : PRAPI.DictionaryAnalytics {
  @objc public static let sessionId: Swift.String
  @objc override final public class var isEnabled: Swift.Bool {
    @objc get
  }
  @objc final public class var environmentInfo: [Swift.String : Any] {
    @objc get
  }
  @objc deinit
}
extension PRAPI.Interest {
  public class func selectedItems() -> [PRAPI.Interest]
  public class func updateUserInterests(forced: Swift.Bool? = nil, completion: (([PRAPI.Interest]) -> Swift.Void)?)
  public var selectable: Swift.Bool {
    get
  }
  public func imageURL(for width: CoreFoundation.CGFloat) -> Foundation.URL?
}
public protocol DownloadableItemContent {
  var isDownloaded: Swift.Bool { get }
  var isDownloading: Swift.Bool { get }
  var downloadProgress: Swift.Int? { get }
  var progressObject: Foundation.Progress? { get }
  var isValidContentInStorage: Swift.Bool { get }
  var isLicenseRequired: Swift.Bool { get }
  @discardableResult
  func download() -> PRPromiseKit.Promise
  func cancelDownload()
  func cleanStorage() async throws
}
public protocol SingleFileDownloadableItemContent : PRAPI.DownloadableItemContent {
  var filePath: Swift.String? { get }
  var url: Foundation.URL? { get }
  var contentPath: Swift.String? { get }
  func prepareForDownload() -> PRPromiseKit.Promise
  func processAfterDownload() -> PRPromiseKit.Promise
}
extension PRAPI.SingleFileDownloadableItemContent where Self : PRCatalogModel.CatalogItemContent {
  public var isLicenseRequired: Swift.Bool {
    get
  }
  public var isValidContentInStorage: Swift.Bool {
    get
  }
  public var isDownloading: Swift.Bool {
    get
  }
  public var downloadProgress: Swift.Int? {
    get
  }
  public var progressObject: Foundation.Progress? {
    get
  }
  public func download() -> PRPromiseKit.Promise
  public func cancelDownload()
  public func validateStorageContent() -> Swift.Result<Swift.Bool, Foundation.FileManager.FileError>
  public func prepareForDownload() -> PRPromiseKit.Promise
  public func processAfterDownload() -> PRPromiseKit.Promise
  public func cleanStorage() async throws
  public func cleanContentStorage() async throws
}
public protocol HotSpotManagerUIDelegate {
  func hotSpotManagerShouldStart(_ manager: PRAPI.HotSpotManager) async -> Swift.Bool
  func hotSpotManagerDidStart(_ manager: PRAPI.HotSpotManager)
  func hotSpotManager(_ manager: PRAPI.HotSpotManager, didUpdateHotSpotsList hotSpots: [PRAPI.GeoFencingHotSpot])
  func hotSpotManager(_ manager: PRAPI.HotSpotManager, didEnterHotSpot hotSpot: PRAPI.GeoFencingHotSpot)
  func hotSpotManager(_ manager: PRAPI.HotSpotManager, didExitHotSpot hotSpot: PRAPI.GeoFencingHotSpot?)
  func hotSpotManager(_ manager: PRAPI.HotSpotManager, didFail error: PRAPI.HotSpotManager.ManagerError)
}
@objc final public class HotSpotManager : ObjectiveC.NSObject, PRAPI.BackgroundTaskRunner {
  public enum ManagerError : Swift.Error {
    case serviceUnavailable
    case locationServiceDenied
    case locationServiceUnavailable
    case accountUnavailable
    case custom(error: any Swift.Error)
  }
  final public var backgroundTasks: Swift.Set<PRAPI.BackgroundTask>
  final public var uiDelegate: (any PRAPI.HotSpotManagerUIDelegate)?
  @objc final public var isOptedOut: Swift.Bool {
    @objc get
    @objc set
  }
  @objc final public var isEnabled: Swift.Bool {
    @objc get
  }
  @objc final public var isLocationServiceEnabled: Swift.Bool {
    @objc get
  }
  @objc final public var isLocationPermissionsRequired: Swift.Bool {
    @objc get
  }
  @Combine.Published @_projectedValueProperty($activeHotSpot) final public var activeHotSpot: PRAPI.GeoFencingHotSpot? {
    get
  }
  final public var $activeHotSpot: Combine.Published<PRAPI.GeoFencingHotSpot?>.Publisher {
    get
  }
  @objc final public var activeHotSpotId: Swift.String? {
    @objc get
  }
  final public var hotSpots: [PRAPI.GeoFencingHotSpot] {
    get
  }
  @objc final public var hotSpotStatus: PRAPI.PRHotSpotStatus {
    @objc get
  }
  public init(storage: any PRConfiguration.KeyValueStore = PRUserDefaults.standard)
  @objc final public func startIfAvailable()
  @objc final public func start()
  @_Concurrency.MainActor final public func start() async
  @objc final public func stop()
  @objc final public func reset()
  @objc final public func validateHotSpotLocations(info: [PRUtils.SPNode])
  @objc deinit
}
@objc extension PRAPI.PRMyLibraryItem : PRAPI.LibraryItemProtocol {
  @objc dynamic public var hotSpotInfo: (any PRAPI.HotSpotInfo)? {
    @objc get
  }
  @objc dynamic public var isRadioSupported: Swift.Bool {
    @objc get
  }
  @objc dynamic public var isLayoutPackageUpdated: Swift.Bool {
    @objc get
    @objc set
  }
}
@_inheritsConvenienceInitializers @_hasMissingDesignatedInitializers @objc public class DictionaryAnalytics : PRAPI.ScreenViewAnalytics {
  @objc deinit
}
public struct BookReadingPosition : Swift.Codable {
  public struct Position : Swift.Codable {
    public let href: Swift.String?
    public let partialCfi: Swift.String?
    public let position: Swift.Int
    public let relativePosition: Swift.Int
    public let mediaType: Swift.String?
    public let deviceName: Swift.String?
    public init(href: Swift.String?, partialCfi: Swift.String?, position: Swift.Int, relativePosition: Swift.Int, mediaType: Swift.String?, deviceName: Swift.String?)
    public func encode(to encoder: any Swift.Encoder) throws
    public init(from decoder: any Swift.Decoder) throws
  }
  public let bookId: Swift.String
  public let position: PRAPI.BookReadingPosition.Position
  public let date: Foundation.Date
  public init(from decoder: any Swift.Decoder) throws
  public func encode(to encoder: any Swift.Encoder) throws
}
@_inheritsConvenienceInitializers @_hasMissingDesignatedInitializers @objc(PRGoogleManager) @objcMembers final public class GoogleManager : ObjectiveC.NSObject {
  @objc public static let shared: PRAPI.GoogleManager?
  @objc public static var isEnabled: Swift.Bool {
    @objc get
  }
  @objc final public func setup()
  @objc final public func handleURL(_ url: Foundation.URL) -> Swift.Bool
  @objc(signInWithPresenter:completion:) final public func signIn(presenter: UIKit.UIViewController?, completion: @escaping (PRAPI.GoogleSignInResult) -> ())
  @objc deinit
}
extension PRAPI.PRMyLibraryItem {
  public func imageKey(page: Swift.UInt, scale: Swift.Int) -> Swift.String
  public func imageKey(page: Swift.UInt, pageHeight: CoreFoundation.CGFloat, placeholderHeight: CoreFoundation.CGFloat) -> Swift.String
  public func imageKey(page: Swift.UInt, height: CoreFoundation.CGFloat) -> Swift.String
  @objc dynamic public func sizeOfThumbnail(page: Swift.UInt, height: CoreFoundation.CGFloat) -> CoreFoundation.CGSize
  @discardableResult
  @objc dynamic public func loadThumbnail(page: Swift.UInt, size thumbSize: CoreFoundation.CGSize, fromCacheOnly cacheOnly: Swift.Bool, completion: @escaping PRThumbnail.PRThumbnailHandler) -> CoreFoundation.CGSize
  @objc dynamic public func cancelLoadingThumbnailForPageNo(_ pageNo: Swift.UInt, height: CoreFoundation.CGFloat)
}
@objc extension PRAPI.PRAccountItem {
  @objc dynamic public var isInitialTrialSubscription: Swift.Bool {
    @objc get
  }
  @objc dynamic public var isInitialTrialSubscriptionExpired: Swift.Bool {
    @objc get
  }
  @objc dynamic public var isInitialTrialBundle: Swift.Bool {
    @objc get
  }
  @objc dynamic public var trialBundle: PRAPI.PRUserBundle? {
    @objc get
  }
  @objc dynamic public var isTrialBundleActive: Swift.Bool {
    @objc get
  }
}
extension PRCatalogModel.Publications : PRAPI.PressCatalogable {
  public typealias Service = PRAPI.PublicationService
  final public var service: PRAPI.PublicationService? {
    get
  }
}
extension PRAPI.NTFSession {
  public func channel<ChannelType>(id: Swift.String, context: CoreData.NSManagedObjectContext) -> ChannelType where ChannelType : PRAPI.Channel
  public func channel<ChannelType>(name: Swift.String, context: CoreData.NSManagedObjectContext) -> ChannelType? where ChannelType : PRAPI.Channel
}
@objc public protocol PROAuth2 {
  @objc func signIn() async throws -> Swift.Bool
}
extension PRAPI.NTFHomeFeedDataService {
  @objc dynamic public func reloadTopStoriesWidget()
}
@objc @_inheritsConvenienceInitializers @_hasMissingDesignatedInitializers final public class PublicationChannelsModel : ObjectiveC.NSObject, PRAPI.ObservableModel {
  public static let instance: PRAPI.PublicationChannelsModel?
  final public var latestNewsChannels: [PRAPI.PublicationChannel]? {
    get
  }
  final public func channel(cid: Swift.String) -> PRAPI.PublicationChannel?
  @objc deinit
}
@_inheritsConvenienceInitializers @_hasMissingDesignatedInitializers @objc final public class BrazeAnalytics : PRAPI.EventAnalytics {
  @objc override final public class var isEnabled: Swift.Bool {
    @objc get
  }
  @objc deinit
}
extension PRAPI.PRCatalog : PRAPI.ObservableModel {
  public var state: PRAPI.ModelState {
    get
    set
  }
}
@objc extension PRAPI.PRCatalog {
  @objc dynamic public func load() -> PRPromiseKit.Promise
}
@available(*, unavailable)
@objc extension PRAPI.PRCatalog {
  @objc dynamic public func _finishLoading()
}
@objc extension Foundation.FileManager {
  @objc @available(swift, obsoleted: 1.0)
  dynamic public func removeResumableData(path: Swift.String, extension: Swift.String)
  @objc dynamic public func removeResumableData(path: Swift.String, extension: Swift.String, resumableExtension: Swift.String = "resumeData")
}
extension PRCatalogModel.DocumentContent : PRAPI.SingleFileDownloadableItemContent {
  final public var url: Foundation.URL? {
    get
  }
  final public var filePath: Swift.String? {
    get
  }
  final public var contentPath: Swift.String? {
    get
  }
}
extension PRCatalogModel.DocumentContent {
  final public var smart: PRSmart.PRSmartObject? {
    get
  }
  final public func processSmart()
}
extension PRCatalogModel.CatalogEntity : PRAPI.CatalogNavigationVariant {
  @objc dynamic public var categoryId: Swift.Int {
    @objc get
  }
  @objc dynamic public var localizedName: Swift.String? {
    @objc get
  }
  @objc dynamic public var count: Swift.Int {
    @objc get
  }
}
extension PRCatalogModel.Section {
  @objc override final public var localizedName: Swift.String? {
    @objc get
  }
}
extension PRCatalogModel.Language {
  @objc override final public var localizedName: Swift.String? {
    @objc get
  }
}
@objc public class EpubContent : ObjectiveC.NSObject {
  public enum ResourceEncryptionInfo : Swift.Int {
    case unencrypted
    case encrypted
    case compressedAndEncrypted
    public init?(rawValue: Swift.Int)
    public typealias RawValue = Swift.Int
    public var rawValue: Swift.Int {
      get
    }
  }
  public typealias BookLicense = PRCatalogModel.ContentLicense
  public var isDownloadedAndValid: Swift.Bool
  public var resourceEncryptedInfo: [Swift.String : PRAPI.EpubContent.ResourceEncryptionInfo]?
  final public let id: Swift.String
  final public let title: Swift.String?
  final public let authorName: Swift.String?
  final public let encryptionKey: Foundation.Data?
  final public let licenseId: Swift.String
  final public let contentHash: Swift.String?
  final public let userContext: Swift.String?
  final public let filePath: Swift.String
  final public let isSample: Swift.Bool
  final public let bookId: Swift.String
  public var book: PRCatalogModel.Book {
    get
  }
  public init?(license: PRAPI.EpubContent.BookLicense, resourceEncryptedInfo: [Swift.String : PRAPI.EpubContent.ResourceEncryptionInfo]? = nil)
  public func content(context: CoreData.NSManagedObjectContext? = nil) -> PRCatalogModel.BookContent
  @objc deinit
}
@objc extension PRAPI.PRMyLibraryItem : PRAPI.ReadingViewItem {
  @objc dynamic public func isEqual(_ item: any PRAPI.ReadingViewItem) -> Swift.Bool
}
@objc public protocol SectionDataSourceProtocol {
  @objc var section: PRConfiguration.PRCatalogSectionType { get }
}
@_hasMissingDesignatedInitializers public class CatalogSectionDataSource : PRAPI.CatalogItemDataSource {
  public var entity: PRCatalogModel.CatalogEntity {
    get
  }
  @objc override public var isLoading: Swift.Bool {
    @objc get
  }
  @objc override public var canLoadMore: Swift.Bool {
    @objc get
  }
  @objc override public func numberOfItems(in section: Swift.Int) -> Swift.Int
  public init?(entity: PRCatalogModel.CatalogEntity)
  convenience public init?(sectionType: PRConfiguration.PRCatalogSectionType)
  convenience public init?(id: Swift.String)
  override public func startLoading()
  @objc deinit
}
@objc @objcMembers final public class AppleSignInResult : PRAPI.SignInResult {
  @objc public init(nameComponent: Foundation.PersonNameComponents? = nil, email: Swift.String? = nil, user: Swift.String? = nil, accessToken: Swift.String? = nil, identityToken: Swift.String? = nil, error: (any Swift.Error)? = nil)
  @objc deinit
}
@objc @_hasMissingDesignatedInitializers @objcMembers final public class MyLibraryItemPrintActor : ObjectiveC.NSObject, PRAPI.PrintableItem {
  @objc final public var isPrintingEnabled: Swift.Bool {
    @objc get
  }
  @objc final public var isPagePrintingEnabled: Swift.Bool {
    @objc get
  }
  @objc final public var isArticlePrintingEnabled: Swift.Bool {
    @objc get
  }
  @objc final public var isArticlePrintInGraphicEnabled: Swift.Bool {
    @objc get
  }
  @objc final public var isIssuePrintingEnabled: Swift.Bool {
    @objc get
  }
  @objc final public var printedPages: Swift.Set<Swift.Int> {
    @objc get
    @objc set
  }
  @objc final public func isPrintingAllowedForPage(_ page: Swift.Int) -> Swift.Bool
  @objc final public func recordIssuePrinted()
  @objc deinit
}
@objc public protocol AnalyticsTracker {
  @objc func track(_ name: PRAnalytics.PRAnalyticsTrackName, parameters: PRAnalytics.AnalyticsParameters?)
}
extension PRAPI.AnalyticsTracker {
  public func track(_ name: PRAnalytics.PRAnalyticsTrackName, parameters: PRAnalytics.AnalyticsParameters?)
}
public enum TrackingSourceType : Swift.String {
  case notDefined
  case newspaper
  case magazine
  case document
  public init?(rawValue: Swift.String)
  public typealias RawValue = Swift.String
  public var rawValue: Swift.String {
    get
  }
}
public struct TrackingIssue {
  public let cid: Swift.String
  public let date: Foundation.Date?
  public let isLatest: Swift.Bool
  public let version: Swift.Int?
  public let smartLayoutVersion: Swift.Int?
  public let title: Swift.String
  public let slug: Swift.String?
  public let sourceType: PRAPI.TrackingSourceType
  public let hotSpotId: Swift.String?
  public let hotSpotIndustry: Swift.String?
}
public struct TrackingArticle {
  public let id: Swift.String
  public let headline: Swift.String
  public let language: Swift.String
}
public protocol ReadingViewAnalyticsTracker : PRAPI.AnalyticsTracker {
  func trackOpenIssueForReading(issue: PRAPI.TrackingIssue)
  func trackIssuePage(issue: PRAPI.TrackingIssue, pageNumber: Swift.Int)
  func trackIssueTextFlow(issue: PRAPI.TrackingIssue)
  func trackArticleView(issue: PRAPI.TrackingIssue, article: PRAPI.TrackingArticle)
  func trackListenView(issue: PRAPI.TrackingIssue)
  func trackTranlated(article: PRAPI.TrackingArticle, languageFrom: Swift.String, laguageTo: Swift.String)
  func trackPrintedPages(issue: PRAPI.TrackingIssue, isFullPage: Swift.Bool, pageNumbers: [Swift.Int])
  func trackPrintedArticle(issue: PRAPI.TrackingIssue, article: PRAPI.TrackingArticle, inReplicaPresentation: Swift.Bool)
}
extension PRAPI.ReadingViewAnalyticsTracker {
  public func trackOpenIssueForReading(issue: PRAPI.TrackingIssue)
  public func trackIssuePage(issue: PRAPI.TrackingIssue, pageNumber: Swift.Int)
  public func trackIssueTextFlow(issue: PRAPI.TrackingIssue)
  public func trackArticleView(issue: PRAPI.TrackingIssue, article: PRAPI.TrackingArticle)
  public func trackListenView(issue: PRAPI.TrackingIssue)
  public func trackTranlated(article: PRAPI.TrackingArticle, languageFrom: Swift.String, laguageTo: Swift.String)
  public func trackPrintedPages(issue: PRAPI.TrackingIssue, isFullPage: Swift.Bool, pageNumbers: [Swift.Int])
  public func trackPrintedArticle(issue: PRAPI.TrackingIssue, article: PRAPI.TrackingArticle, inReplicaPresentation: Swift.Bool)
}
extension PRAPI.PRBundle {
  @objc dynamic public var realCIDs: [Swift.String]? {
    @objc get
  }
  @objc dynamic public func containsCIDs(_ cids: Swift.Set<Swift.String>) -> Swift.Bool
}
@objc extension PRAPI.PRBrazeAnalytics {
  @objc dynamic public class var isUserAvailable: Swift.Bool {
    @objc get
  }
  @objc dynamic public class var userId: Swift.String? {
    @objc get
  }
  @objc dynamic public class func logCustomEvent(_ name: Swift.String, properties: [Swift.AnyHashable : Any]?)
  @objc dynamic public class func subscribeToEmails(subscribe: Swift.Bool)
  @objc(setCustomAttributeWithKey:boolValue:) dynamic public class func setCustomAttribute(_ key: Swift.String, value: Swift.Bool)
  @objc(setCustomAttributeWithKey:doubleValue:) dynamic public class func setCustomAttribute(_ key: Swift.String, value: Swift.Double)
  @objc(setCustomAttributeWithKey:intValue:) dynamic public class func setCustomAttribute(_ key: Swift.String, value: Swift.Int)
  @objc(setCustomAttributeWithKey:stringValue:) dynamic public class func setCustomAttribute(_ key: Swift.String, value: Swift.String)
  @objc(setCustomAttributeWithKey:dateValue:) dynamic public class func setCustomAttribute(_ key: Swift.String, value: Foundation.Date)
  @objc dynamic public class func setCustomAttribute(_ key: Swift.String, array: [Swift.String]?)
  @objc dynamic public class func unsetCustomAttribute(_ key: Swift.String)
  @objc dynamic public class func setEmail(_ email: Swift.String?)
  @objc dynamic public class func setFirstName(_ firstName: Swift.String?)
  @objc dynamic public class func setLastName(_ lastName: Swift.String?)
  @objc dynamic public class func changeUser(userId: Swift.String)
}
public enum AccessError : PRUtils.DefaultLocalizedError {
  case unexpected
  case restricted
  case expired
  case limitExceeded
  case noFreeProduct
  case noProducts
  public static func == (a: PRAPI.AccessError, b: PRAPI.AccessError) -> Swift.Bool
  public func hash(into hasher: inout Swift.Hasher)
  public var hashValue: Swift.Int {
    get
  }
}
@_inheritsConvenienceInitializers @_Concurrency.MainActor final public class BookService : PRAPI.CatalogService<PRCatalogModel.Books> {
  nonisolated override final public var updateInterval: Foundation.TimeInterval {
    get
  }
  @_Concurrency.MainActor final public var license: PRAPI.BookLicenseService? {
    get
  }
  @_Concurrency.MainActor final public var user: PRAPI.BookUserService? {
    get
  }
  @discardableResult
  @_Concurrency.MainActor final public func loadBookDetails(id: Swift.String, context: CoreData.NSManagedObjectContext? = nil) async throws -> PRCatalogModel.Book
  @_Concurrency.MainActor final public func loadBooks(ids: [Swift.String], context: CoreData.NSManagedObjectContext? = nil) async throws -> [PRCatalogModel.Book]
  @_Concurrency.MainActor final public func purchaseBook(id: Swift.String, options: PRCatalogModel.CatalogItemContentOption, preloadDetails: Swift.Bool = false, itemInfo: inout PRAPI.CatalogServiceItemInfo) async throws
  @_Concurrency.MainActor override final public func preload() async
  @_Concurrency.MainActor override final public func cancelPreloading()
  override nonisolated public init(item: PRCatalogModel.Books)
  @objc deinit
}
extension PRCatalogModel.BookContent : PRAPI.SingleFileDownloadableItemContent {
  public var filePath: Swift.String? {
    get
  }
  public var url: Foundation.URL? {
    get
  }
  public var isLicenseRequired: Swift.Bool {
    get
  }
  public var contentPath: Swift.String? {
    get
  }
  @discardableResult
  public func prepareForDownload() -> PRPromiseKit.Promise
}
@objc @objcMembers open class SignInResult : ObjectiveC.NSObject {
  @objc final public let userId: Swift.String?
  @objc final public let accessToken: Swift.String?
  @objc final public let identityToken: Swift.String?
  @objc final public let email: Swift.String?
  @objc final public let firstName: Swift.String?
  @objc final public let lastName: Swift.String?
  @objc final public let displayName: Swift.String?
  @objc final public let profileImageUrl: Swift.String?
  @objc final public let error: (any Swift.Error)?
  @objc public init(userId: Swift.String? = nil, accessToken: Swift.String? = nil, identityToken: Swift.String? = nil, email: Swift.String? = nil, firstName: Swift.String? = nil, lastName: Swift.String? = nil, displayName: Swift.String? = nil, profileImageUrl: Swift.String? = nil, error: (any Swift.Error)? = nil)
  @objc deinit
}
extension StoreKit.SKProduct {
  @objc dynamic public var prBundle: PRAPI.PRBundle? {
    @objc get
  }
}
extension PRAPI.PROptions {
  @objc dynamic public func helpCenterUrl(section: Swift.String?, isOnline: Swift.UnsafeMutablePointer<Swift.Bool>?) -> Swift.String
}
@objc extension PRCatalogModel.CatalogItem {
  public enum LoadingError : PRUtils.DefaultLocalizedError {
    case unableToLoad
    case noContent
    case unexpectedResponse
    case noServiceUrlProvided
    public static func == (a: PRCatalogModel.CatalogItem.LoadingError, b: PRCatalogModel.CatalogItem.LoadingError) -> Swift.Bool
    public func hash(into hasher: inout Swift.Hasher)
    public var hashValue: Swift.Int {
      get
    }
  }
  @objc dynamic public class func loadItem(id: Swift.String, catalog: PRCatalogModel.Catalog, context: CoreData.NSManagedObjectContext) -> PRPromiseKit.Promise
}
@objc extension PRCatalogModel.CatalogItem {
  @objc dynamic public func downloadState(options: PRCatalogModel.CatalogItemContentOption = []) -> PRAPI.PRTitleItemExemplarState
  @objc dynamic public func downloadProgress(options: PRCatalogModel.CatalogItemContentOption = []) -> Swift.Int
  @objc dynamic public func downloadProgressObject(options: PRCatalogModel.CatalogItemContentOption = []) -> Foundation.Progress?
}
public struct BookLicenseCheckoutResult : Swift.Decodable {
  public struct Details : Swift.Decodable {
    public let orderId: Swift.String
    public let currency: Swift.String?
    public let subtotal: Swift.Float?
    public let formattedSubtotal: Swift.String?
    public let discount: Swift.Float?
    public let formattedDiscount: Swift.String?
    public let total: Swift.Float?
    public let formattedTotal: Swift.String?
    public let products: [PRAPI.BookLicenseProduct]?
    public init(from decoder: any Swift.Decoder) throws
  }
  public let orderId: Swift.String
  public let status: Swift.String
  public let details: PRAPI.BookLicenseCheckoutResult.Details?
  public var isPending: Swift.Bool {
    get
  }
  public var isApproved: Swift.Bool {
    get
  }
  public init(from decoder: any Swift.Decoder) throws
}
extension PRCatalogModel.BookLicense {
  public struct DTO : Swift.Decodable {
    public let id: Swift.String
    public let bookId: Swift.String
    public let startDate: Foundation.Date
    public let endDate: Foundation.Date?
    public init(from decoder: any Swift.Decoder) throws
  }
  @discardableResult
  public class func instance(info: PRCatalogModel.BookLicense.DTO, context: CoreData.NSManagedObjectContext) -> Self?
}
@objc public protocol AutoTranslationStateAnalyticsProvider : PRAnalytics.AnalyticsProvider {
  @objc var isAutoTranslationOn: Swift.Bool { get }
}
extension PRAPI.AutoTranslationStateAnalyticsProvider {
  public func trackAutoTranslationState()
}
extension PRAPI.PRMyLibrary {
  @objc(sortedItemsIncludingPurchaseAdvises:) dynamic public func sortedItems(includeAdvises: Swift.Bool) -> [any PRAPI.PRCatalogItem]
}
extension PRAPI.PRWebServer : PRAPI.PRWebServerBookRegister {
  @objc dynamic public func registerBook(withId bookId: Swift.String, bookFileDirURL: Foundation.URL) -> Foundation.URL?
  @objc dynamic public func registerBook(withId bookId: Swift.String, resourceDataProvider dataProvider: @escaping PRAPI.BookResourceDataProviderBlock) -> Foundation.URL?
  @objc dynamic public func unregisterBook(withId bookId: Swift.String)
}
@objc public protocol PDVAnalyticsProvider : PRAnalytics.AnalyticsProvider {
}
extension PRAPI.PDVAnalyticsProvider {
  public func trackPDVDidAppear(titleItem: PRAPI.PRTitleItem)
  public func trackPDVSubscribeToRead(titleKey: Swift.String)
  public func trackPDVSupplementsTab()
  public func trackPDVOnlineStoriesTab()
  public func trackPDVLatestIssuesTab()
}
extension PRCatalogModel.CatalogItem : PRAPI.LibraryItemProtocol {
  @objc dynamic public var orderDate: Foundation.Date? {
    @objc get
  }
  @objc dynamic public var isLocked: Swift.Bool {
    @objc get
    @objc set
  }
  @objc dynamic public var isMarkedToDeleteContent: Swift.Bool {
    @objc get
    @objc set
  }
  @objc dynamic public var isSelected: Swift.Bool {
    @objc get
    @objc set
  }
  @objc dynamic public var hotSpotInfo: (any PRAPI.HotSpotInfo)? {
    @objc get
  }
  @objc dynamic public var isDownloaded: Swift.Bool {
    @objc get
  }
  @objc dynamic public var isRadioSupported: Swift.Bool {
    @objc get
  }
  @objc dynamic public func lock(_ locked: Swift.Bool)
}
extension PRCatalogModel.CatalogItem : PRAPI.OpenedItem {
  @objc dynamic public var isNew: Swift.Bool {
    @objc get
  }
  @objc dynamic public func markAsOpened()
}
@objc @objcMembers final public class LocationRect : ObjectiveC.NSObject {
  @objc final public let northEast: CoreLocation.CLLocationCoordinate2D
  @objc final public let southWest: CoreLocation.CLLocationCoordinate2D
  @objc public init?(northEast: CoreLocation.CLLocationCoordinate2D, southWest: CoreLocation.CLLocationCoordinate2D)
  @objc deinit
}
@objc extension PRAPI.PRServiceClient {
  @objc dynamic public func wrappedResponse(json: Any) -> Any?
}
extension PRAPI.PRMyLibrary {
  @objc dynamic public var downloads: PRCatalogModel.Downloads {
    @objc get
    @objc set
  }
}
extension PRAPI.NTFFeed {
  public func updateAccessibility()
}
extension PRThumbnail.PRThumbnailsManager {
  public func thumbnail(mastheadOriginalId: Swift.String, mastheadTemplateId: Swift.String, height: CoreFoundation.CGFloat, style: UIKit.UIUserInterfaceStyle) -> PRThumbnail.PRThumbnailMasthead?
}
public protocol ObservableViewModel : PRAPI.ObservableModel {
}
extension PRAPI.ObservableViewModel {
  public func triggerObservers(_ action: @escaping (any PRAPI.LoadableModelObserver) -> ())
}
extension PRAPI.PRSourceList : PRAPI.ObservableModel {
  public var state: PRAPI.ModelState {
    get
    set
  }
  public func addObserver(_ observer: any PRAPI.LoadableModelObserver)
  public func removeObserver(_ observer: (any PRAPI.LoadableModelObserver)?)
}
@_inheritsConvenienceInitializers open class DataSourceSelectable<AnItem> : PRAPI.DataSource<AnItem> {
  open var hasSelectedItems: Swift.Bool {
    get
  }
  open func selectItem(_ item: AnItem, select: Swift.Bool)
  @objc required dynamic public init()
  override public init(observer: (any PRAPI.DataSourceObserver)? = nil)
  @objc deinit
}
extension PRAPI.PRSubscription {
  public typealias Response = ([Swift.String : Any]?, (any Swift.Error)?) -> ()
  public enum ArticleFields : Swift.String {
    case snippets
    case all
    public init?(rawValue: Swift.String)
    public typealias RawValue = Swift.String
    public var rawValue: Swift.String {
      get
    }
  }
  public func requestArticles(ids: [Swift.String], language: Swift.String? = nil, fields: PRAPI.PRSubscription.ArticleFields = .all) -> PRPromiseKit.Promise
  public func requestArticles(ids: [Swift.String], language: Swift.String? = nil, fields: PRAPI.PRSubscription.ArticleFields = .all) async throws -> [[Swift.String : Any]]
  @objc dynamic public func saveAccessTokenToSharedUserDefaults(_ accessToken: Swift.String?)
}
@objc extension PRCatalogModel.CatalogItem {
  @objc dynamic public var isReadyToBuy: Swift.Bool {
    @objc get
  }
  @objc dynamic public var isBought: Swift.Bool {
    @objc get
  }
}
@_Concurrency.MainActor public protocol Preloadable : AnyObject {
  @_Concurrency.MainActor var preloadTask: _Concurrency.Task<(), Swift.Never>? { get set }
  @_Concurrency.MainActor func preload() async
  @_Concurrency.MainActor func cancelPreloading()
}
extension PRAPI.Preloadable {
  @_Concurrency.MainActor public func cancelPreloading()
  @_Concurrency.MainActor public func discardPreloadingTask()
}
@objc final public class MLIFeedDataService : PRAPI.NTFDataService {
  @objc public init(mid: Swift.String)
  @objc override final public func requestData() -> PRPromiseKit.Promise
  @objc final public func updateArticlesWithDefaultLanguageLayoutPackage() throws
  @objc deinit
}
@_Concurrency.MainActor extension PRAPI.MLIFeedDataService {
  @objc @_Concurrency.MainActor final public func translate(article: PRSmart.PRSmartArticle, language: Swift.String) async throws
  @_Concurrency.MainActor final public func translateShortContent(to language: Swift.String) async throws
}
@_hasMissingDesignatedInitializers @objc public class Analytics : ObjectiveC.NSObject, PRAnalytics.AnalyticsService {
  public enum Event : Swift.String {
    case PR_Accounts
    case PR_All_Payment_Options
    case PR_Article_Text
    case PR_Bookmark_Changed
    case PR_Bookmarks
    case PR_Catalog
    case PR_Comments
    case PR_Download
    case PR_Downloaded
    case PR_Feed_Flow
    case PR_First_Launch
    case PR_Hotspot_Map
    case PR_Issue_Order
    case PR_Issue_Flow
    case PR_Listen
    case PR_Onboarding_Interests
    case PR_Onboarding_Titles
    case PR_Paid
    case PR_PushNotification_Received
    case PR_Payment_Restore_Started, PR_Payment_Restore
    case PR_Payment_Selected
    case PR_Replica_Page
    case PR_Replica
    case PR_Search_Results
    case PR_Signin_Form, PR_Signup_Form
    case PR_Settings
    case PR_Search
    case PR_Share
    case PR_Signed_Up, PR_Signed_In
    case PR_Gifted_Issue_Adget
    case PR_Gifted_Issue_Video_Played
    public init?(rawValue: Swift.String)
    public typealias RawValue = Swift.String
    public var rawValue: Swift.String {
      get
    }
  }
  @objc public class var isEnabled: Swift.Bool {
    @objc get
  }
  @objc public func track(_ name: PRAnalytics.PRAnalyticsTrackName, parameters: PRAnalytics.AnalyticsParameters?)
  @objc deinit
}
extension PRCatalogModel.CatalogEntity {
  final public var loadableCatalog: (any PRAPI.PressCatalogable)? {
    get
  }
  final public var service: (any PRAPI.LoadableCatalog)? {
    get
  }
}
@objc extension PRAPI.PRAccountItem {
  @objc dynamic public var remainingFreeCredits: Swift.Int {
    @objc get
  }
  @objc dynamic public var remainingFreeCreditsSufficient: Swift.Bool {
    @objc get
  }
  @objc dynamic public var remainingFreeCreditsLow: Swift.Bool {
    @objc get
  }
  @objc dynamic public func isCreditSufficient(_ credit: Swift.Int) -> Swift.Bool
  @objc dynamic public func isCreditLow(_ credit: Swift.Int) -> Swift.Bool
}
@_inheritsConvenienceInitializers @objc final public class KYMAnalytics : ObjectiveC.NSObject, PRAnalytics.LegacyAnalyticsService {
  @objc override dynamic public init()
  @objc public static var isEnabled: Swift.Bool {
    @objc get
  }
  @objc final public func track(_ name: PRAnalytics.PRAnalyticsTrackName, parameters: PRAnalytics.AnalyticsParameters?)
  @objc deinit
}
@objc extension PRAPI.PRSourceList {
  @objc dynamic public func wait() -> PRPromiseKit.Promise
}
extension PRAPI.PRSubscription {
  @objc dynamic public func requestMastheadInfo(cid: Swift.String, completion: @escaping PRAPI.PRSubscription.Response)
  public func requestOwnerInfo(cid: Swift.String, completion: @escaping PRAPI.PRSubscription.Response)
}
@_inheritsConvenienceInitializers @_Concurrency.MainActor final public class NTFArticleItemService : PRAPI.MOService<PRAPI.NTFArticleItem, PRAPI.NTFCoreDataController>, PRAPI.ArticleService {
  @_Concurrency.MainActor @objc final public func contentRestrictions() async -> PRAPI.NTFContentRestrictions?
  @_Concurrency.MainActor @objc final public func updateRelatedArticles() async throws -> Swift.Bool
  @_Concurrency.MainActor @objc final public func loadFullContent() async throws
  @_Concurrency.MainActor @objc final public func translate(language: Swift.String) async throws
  @_Concurrency.MainActor @objc final public func updateListenDuration() async throws
  override nonisolated public init(item: PRAPI.NTFArticleItem)
  @objc deinit
}
@objc @objcMembers public class CatalogSectionSchemeOption : ObjectiveC.NSObject, Swift.OptionSet {
  @objc public static let showTitle: PRAPI.CatalogSectionSchemeOption
  @objc public static let showSeeAllButton: PRAPI.CatalogSectionSchemeOption
  @objc public static let standout: PRAPI.CatalogSectionSchemeOption
  @objc public static let newRibbon: PRAPI.CatalogSectionSchemeOption
  @objc public static let combine: PRAPI.CatalogSectionSchemeOption
  @objc public static let formFromFavorites: PRAPI.CatalogSectionSchemeOption
  @objc public static let promoteLocals: PRAPI.CatalogSectionSchemeOption
  @objc public static let openReader: PRAPI.CatalogSectionSchemeOption
  @objc final public let rawValue: Swift.Int
  @objc override dynamic public var hash: Swift.Int {
    @objc get
  }
  @objc required public init(rawValue: Swift.Int)
  @objc override dynamic public func isEqual(_ object: Any?) -> Swift.Bool
  public typealias ArrayLiteralElement = PRAPI.CatalogSectionSchemeOption
  public typealias Element = PRAPI.CatalogSectionSchemeOption
  public typealias RawValue = Swift.Int
  @objc deinit
}
public protocol SignInManagerProtocol {
  associatedtype ResultType : PRAPI.SignInResult
  static var shared: Self { get }
  func signIn(_ handler: @escaping (Self.ResultType) -> ())
}
extension PRCatalogModel.Book {
  @objc override final public var isNew: Swift.Bool {
    @objc get
  }
}
@objc public protocol ArticleService {
  @objc func contentRestrictions() async -> PRAPI.NTFContentRestrictions?
  @objc func updateRelatedArticles() async throws -> Swift.Bool
  @objc func loadFullContent() async throws
  @objc func translate(language: Swift.String) async throws
  @objc func updateListenDuration() async throws
}
@objc extension PRAPI.NTFArticleItem {
  @objc dynamic public var service: any PRAPI.ArticleService {
    @objc get
  }
}
public protocol BookPurchaseAnalyticsProvider : PRAnalytics.AnalyticsProvider {
}
extension PRAPI.BookPurchaseAnalyticsProvider {
  public func trackBookDownloadLimitExceeded()
}
@objc @_inheritsConvenienceInitializers @objcMembers final public class AppsFlyerProxy : ObjectiveC.NSObject {
  public static let shared: (any PRAPI.PRAppsFlyer)?
  @objc override dynamic public init()
  @objc deinit
}
extension PRAPI.NTFArticleItem {
  @objc dynamic public func channel() -> PRAPI.PublicationChannel?
}
public struct BookLicenseRenewResult : Swift.Decodable {
  public enum Status : Swift.String, Swift.Decodable {
    case unchanged
    case renewed
    case purchaseRequired
    case gracePeriodAdded
    public init?(rawValue: Swift.String)
    public typealias RawValue = Swift.String
    public var rawValue: Swift.String {
      get
    }
  }
  public struct Message : Swift.Decodable {
    public let id: Swift.String
    public let messageTemplate: Swift.String
    public let arguments: [Swift.String : Swift.String]?
    public var message: Swift.String {
      get
    }
    public init(from decoder: any Swift.Decoder) throws
  }
  public let status: PRAPI.BookLicenseRenewResult.Status
  public let message: PRAPI.BookLicenseRenewResult.Message?
  public let license: PRCatalogModel.BookLicense.DTO?
  public init(from decoder: any Swift.Decoder) throws
}
public protocol LoadableCatalog {
  var updateInterval: Foundation.TimeInterval { get }
  var mainContext: CoreData.NSManagedObjectContext { get }
  func catalog(context: CoreData.NSManagedObjectContext) -> (any PRAPI.PressCatalogable)?
  func loadBatch(entity: PRCatalogModel.CatalogEntity) async throws -> [PRCatalogModel.CatalogItem]
}
extension Foundation.NSNotification.Name {
  public static let catalogItemsUpdated: Foundation.Notification.Name
}
@_Concurrency.MainActor extension PRAPI.LoadableCatalog {
  @_Concurrency.MainActor public var catalog: (any PRAPI.PressCatalogable)? {
    get
  }
  @_Concurrency.MainActor public func load(entity: PRCatalogModel.CatalogEntity) async throws -> [PRCatalogModel.CatalogItem]
  @_Concurrency.MainActor public func load(sectionId: PRCatalogModel.Section.Id) async throws -> [PRCatalogModel.CatalogItem]
}
extension PRAPI.LoadableCatalog {
  public func section(id: PRCatalogModel.Section.Id, account: PRAPI.PRAccountItem? = nil, context: CoreData.NSManagedObjectContext) throws -> PRCatalogModel.Section
  public func enity<T>(id: Swift.String, account: PRAPI.PRAccountItem? = nil, context: CoreData.NSManagedObjectContext) throws -> T where T : PRCatalogModel.CatalogEntity
}
@objc(PRFacebookSharingDelegate) public protocol FacebookSharingDelegate : ObjectiveC.NSObjectProtocol {
  @objc func facebookSharingDidComplete(results: [Swift.String : Any])
  @objc func facebookSharingDidFail(error: any Swift.Error)
  @objc func facebookSharingDidCancel()
}
@_inheritsConvenienceInitializers @_hasMissingDesignatedInitializers @objc(PRFacebookManager) @objcMembers final public class FacebookManager : ObjectiveC.NSObject {
  @objc public static let shared: PRAPI.FacebookManager?
  @objc public static var isEnabled: Swift.Bool {
    @objc get
  }
  @objc final public var isAdvertiserTrackingEnabled: Swift.Bool
  @objc final public func application(_ application: UIKit.UIApplication, open url: Foundation.URL, sourceApplication: Swift.String?, annotation: Any?) -> Swift.Bool
  @objc final public func setup()
  @objc @discardableResult
  final public func application(_ application: UIKit.UIApplication, didFinishLaunchingWithOptions launchOptions: [UIKit.UIApplication.LaunchOptionsKey : Any]? = nil) -> Swift.Bool
  @objc final public func resetCurrentTokenAndProfile()
  @objc final public func requestAccessToAccount(permissions: [Swift.String], presenter: UIKit.UIViewController?, completion: @escaping (_ signInResult: PRAPI.SignInResult?, _ tokenRefreshed: Swift.Bool, _ error: (any Swift.Error)?) -> ())
  @objc final public func logOut()
  @objc final public func share(url: Swift.String, text: Swift.String?, presenter: UIKit.UIViewController?, delegate: any PRAPI.FacebookSharingDelegate)
  @objc deinit
}
@objc @_inheritsConvenienceInitializers @objcMembers final public class AutoTranslationZone : PRSyntacticSugar.PROptionSet {
  @objc public static let downloadedFeed: PRAPI.AutoTranslationZone
  @objc public static let downloadedArticleDetails: PRAPI.AutoTranslationZone
  @objc public static let feed: PRAPI.AutoTranslationZone
  @objc public static let articleDetails: PRAPI.AutoTranslationZone
  @objc required public init(rawValue: Swift.Int)
  public typealias ArrayLiteralElement = PRAPI.AutoTranslationZone
  public typealias Element = PRAPI.AutoTranslationZone
  public typealias RawValue = Swift.Int
  @objc deinit
}
@objc extension PRAPI.AutoTranslationZone {
  @objc final public var analyticsZone: PRAnalytics.PRAnalyticsAutoTranslationZoneType {
    @objc get
  }
}
public struct AuthAnalyticsContext {
  public let product: PRAPI.PRProduct?
  public let containerId: Swift.String?
  public init(product: PRAPI.PRProduct?, containerId: Swift.String?)
}
public protocol SignInAnalyticsProvider : PRAnalytics.AnalyticsProvider {
  var authView: PRAnalytics.PRAnalyticsAuthView { get }
  var authMethod: PRAnalytics.PRAnalyticsAuthMethod? { get }
  var authType: PRAnalytics.PRAnalyticsAuthType? { get }
  var authContext: PRAPI.AuthAnalyticsContext? { get }
}
extension PRAPI.SignInAnalyticsProvider {
  public var authMethod: PRAnalytics.PRAnalyticsAuthMethod? {
    get
  }
  public var authType: PRAnalytics.PRAnalyticsAuthType? {
    get
  }
  public var authContext: PRAPI.AuthAnalyticsContext? {
    get
  }
  public func trackSignInDidAppear()
  public func trackSignInTap()
  public func trackSignUpTap()
  public func trackSocialSignInTap()
  public func trackAuthorize(state: PRAnalytics.OperationState)
}
@objc extension PRAPI.PRTitleItemExemplar {
  @objc dynamic public func thumbnail(size: CoreFoundation.CGSize, page: Swift.Int) -> PRThumbnail.PRThumbnailSource?
}
@objc extension PRCatalogModel.Book {
  @objc override final public var sourceType: PRCatalogModel.PRSourceType {
    @objc get
  }
}
@objc public protocol CatalogFacade {
  @objc var isEmpty: Swift.Bool { get }
  @objc var loadedPublications: [any PRAPI.PRCatalogItem]? { get }
  @objc var navigationFilters: [any PRAPI.CatalogNavigation] { get }
  @objc var categories: [any PRAPI.CatalogNavigationVariant]? { get }
  @objc var countries: [any PRAPI.CountryNavigationVariant]? { get }
}
public protocol ObservableCatalogFacade : PRAPI.CatalogFacade, PRAPI.ObservableModel {
}
extension PRCatalogModel.ContentLicense : @retroactive PRCoreDataUtils.UpdatableMO {
  public typealias Payload = PRCatalogModel.ContentLicense.DTO
  public struct DTO : PRCoreDataUtils.StringIdentifiable {
    public let id: Swift.String
  }
  public class func payload(with info: [Swift.String : Any]) -> PRCatalogModel.ContentLicense.DTO?
  public func update(payload: PRCatalogModel.ContentLicense.DTO)
}
@_inheritsConvenienceInitializers @_hasMissingDesignatedInitializers @objc final public class AnalyticsTrackerAdapter : ObjectiveC.NSObject {
  @objc public init(tracker: any PRAPI.AnalyticsTracker)
  @objc deinit
}
extension PRAPI.AnalyticsTrackerAdapter : PRAnalytics.AnalyticsService {
  @objc public static var isEnabled: Swift.Bool {
    @objc get
  }
  @objc final public func track(_ name: PRAnalytics.PRAnalyticsTrackName, parameters: PRAnalytics.AnalyticsParameters?)
}
@objc @_inheritsConvenienceInitializers final public class AnalyticsValueProvider : ObjectiveC.NSObject {
  @objc(valueForMainMenuParameter:) final public class func value(parameter: PRAnalytics.PRAnalyticsMainMenu) -> Swift.String
  @objc override dynamic public init()
  @objc deinit
}
@objc extension PRDIContainer.DIContainer {
  @objc final public func removeAppDependencies()
  @objc final public func registerAppDependencies()
}
extension PRDIContainer.DIContainer {
  public enum DIKey : Swift.String {
    case twitterAuth
    public init?(rawValue: Swift.String)
    public typealias RawValue = Swift.String
    public var rawValue: Swift.String {
      get
    }
  }
  final public func resolve<T>(key: PRDIContainer.DIContainer.DIKey) -> T?
  final public func hasDependency(key: PRDIContainer.DIContainer.DIKey) -> Swift.Bool
}
@available(*, unavailable)
@objc extension PRDIContainer.DIContainer {
  @objc final public func twitterAuth() -> Any?
  @objc final public func hasTwitterAuth() -> Swift.Bool
}
public protocol UnitTestDIRegistrar {
  func registerUnitTestsDependencies()
}
extension PRAPI.PRAPIRequest {
  public var notification: Foundation.Notification.Name {
    get
  }
}
extension Foundation.NSNotification.Name {
  public static let translationPairsUpdated: Foundation.Notification.Name
}
@objc extension Foundation.NSNotification {
  @objc public static let translationPairsUpdated: Foundation.Notification.Name
}
@objc public protocol TranslationLanguagesInfo {
  @objc var isTranslationEnabled: Swift.Bool { get }
  @objc var translationLanguages: [Swift.String : Any]? { get }
}
@objc @_inheritsConvenienceInitializers @objcMembers final public class TranslateOptions : PRAPI.BaseTranslateOptions {
  @objc(autoTranslate) final public let auto: PRAPI.AutoTranslateOptions
  @objc final public var showTranslate: Swift.Bool {
    @objc get
  }
  @objc final public var showAutoTranslateSettings: Swift.Bool {
    @objc get
  }
  @objc override public init(languagesInfo: any PRAPI.TranslationLanguagesInfo)
  @objc deinit
}
@objc @_inheritsConvenienceInitializers @objcMembers final public class AutoTranslateOptions : PRAPI.BaseTranslateOptions {
  @objc final public var languagePairs: [PRAPI.AutoTranslateLanguagePair] {
    @objc get
    @objc set
  }
  @objc final public var hideSaveLanguagePairAlertView: Swift.Bool {
    @objc get
    @objc set
  }
  @objc final public var isOff: Swift.Bool {
    @objc get
    @objc set
  }
  @objc override final public func isAvailable(for account: PRAPI.PRAccountItem? = nil) -> Swift.Bool
  @objc final public var zones: PRAPI.AutoTranslationZone {
    @objc get
  }
  @objc final public var languagePairsLimit: Swift.Int {
    @objc get
  }
  @objc final public func isAvailable(zone: PRAPI.AutoTranslationZone, account: PRAPI.PRAccountItem? = nil) -> Swift.Bool
  @objc override public init(languagesInfo: any PRAPI.TranslationLanguagesInfo)
  @objc deinit
}
@objc public class BaseTranslateOptions : ObjectiveC.NSObject {
  @objc public var lastSelectedLanguageISOCode: Swift.String? {
    @objc get
    @objc set
  }
  public init(languagesInfo: any PRAPI.TranslationLanguagesInfo)
  @objc(isAvailableForAccount:) public func isAvailable(for account: PRAPI.PRAccountItem? = nil) -> Swift.Bool
  @objc public func isLanguageSupported(isoCode: Swift.String) -> Swift.Bool
  @objc public func translationLanguageISOCodes(sourceLanguageISOCode isoCode: Swift.String) -> [Swift.String]?
  @objc public func languageName(isoCode: Swift.String) -> Swift.String?
  @objc public func translationLanguageNames(sourceLanguageISOCode: Swift.String) -> [Swift.String]
  @objc deinit
}
@objc extension Foundation.UserDefaults : PRAPI.TranslationLanguagesInfo {
  @objc dynamic public var isTranslationEnabled: Swift.Bool {
    @objc get
  }
  @objc dynamic public var translationLanguages: [Swift.String : Any]? {
    @objc get
  }
}
extension PRAPI.PRBaseBundle {
  @objc override dynamic open var debugDescription: Swift.String {
    @objc get
  }
}
extension PRAPI.PRBundle {
  @objc override dynamic open var debugDescription: Swift.String {
    @objc get
  }
}
extension PRAPI.PRUserBundle {
  @objc override dynamic open var debugDescription: Swift.String {
    @objc get
  }
}
extension PRAPI.PRConsumableBundle {
  @objc override dynamic open var debugDescription: Swift.String {
    @objc get
  }
}
extension PRAPI.PRSubscriptionBundle {
  @objc override dynamic open var debugDescription: Swift.String {
    @objc get
  }
}
extension Foundation.NSNotification.Name {
  public static let libraryItemDownloadStarted: Foundation.Notification.Name
  public static let libraryItemDownloadFinished: Foundation.Notification.Name
  public static let libraryItemDownloadProgress: Foundation.Notification.Name
  public static let libraryItemDownloadCancelled: Foundation.Notification.Name
  public static let libraryItemDownloadError: Foundation.Notification.Name
  public static let libraryItemOpened: Foundation.Notification.Name
  public static let libraryItemLockChanged: Foundation.Notification.Name
  public static let libraryItemDownloadMenuError: Foundation.Notification.Name
}
@objc extension Foundation.NSNotification {
  @objc public static let libraryItemDownloadStarted: Foundation.Notification.Name
  @objc public static let libraryItemDownloadCancelled: Foundation.Notification.Name
  @objc public static let libraryItemDownloadProgress: Foundation.Notification.Name
  @objc public static let libraryItemDownloadError: Foundation.Notification.Name
  @objc public static let libraryItemDownloadFinished: Foundation.Notification.Name
  @objc public static let libraryItemOpened: Foundation.Notification.Name
  @objc public static let libraryItemLockChanged: Foundation.Notification.Name
  @objc public static let libraryItemDownloadMenuError: Foundation.Notification.Name
}
@objc public protocol LibraryItemProtocol : PRAPI.OpenedItem, PRAPI.PRCatalogItem {
  @objc var orderDate: Foundation.Date? { get }
  @objc var isDownloaded: Swift.Bool { get }
  @objc var isLocked: Swift.Bool { get }
  @objc var isMarkedToDeleteContent: Swift.Bool { get }
  @objc var isSelected: Swift.Bool { get set }
  @objc var hotSpotInfo: (any PRAPI.HotSpotInfo)? { get }
  @objc var isRadioSupported: Swift.Bool { get }
  @objc func lock(_ locked: Swift.Bool)
}
@objc extension ObjectiveC.NSObject {
  @objc dynamic public func observeLibraryNotifications(selector: ObjectiveC.Selector, object: (any PRAPI.LibraryItemProtocol)? = nil)
  @objc dynamic public func observeLibraryNotifications(selector: ObjectiveC.Selector, object: (any PRAPI.LibraryItemProtocol)? = nil, observe: Swift.Bool)
}
extension PRAPI.PRAccountItem : PRAnalytics.AnalyticsAccount {
  public var enablePromotional: Swift.Bool? {
    get
  }
  public var isOnboardingStarted: Swift.Bool {
    get
  }
  public var isOnboardingSkipped: Swift.Bool {
    get
  }
  public var serviceName: Swift.String {
    get
  }
  public var linkedServices: [Swift.String] {
    get
  }
  public var hasActivePaidSubscription: Swift.Bool {
    get
  }
  public var sponsorshipInfo: any PRAnalytics.Sponsorship {
    get
  }
}
@objc public enum CatalogNavigationType : Swift.Int {
  case unknown
  case newspaper
  case magazine
  case book
  case free
  case country
  case aCountry
  case language
  case all
  case section
  case category
  case group
  case favorite
  case publicationType
  case genre
  case region
  case mainCID
  case minRate
  case cid
  case subscription
  case customCatalogTitle
  case latestPublishDay
  public var isDropdown: Swift.Bool {
    get
  }
  public init?(rawValue: Swift.Int)
  public typealias RawValue = Swift.Int
  public var rawValue: Swift.Int {
    get
  }
}
@objc public enum CatalogType : Swift.Int {
  case unknown
  case publication
  case book
  public init?(rawValue: Swift.Int)
  public typealias RawValue = Swift.Int
  public var rawValue: Swift.Int {
    get
  }
}
@objc public protocol CatalogNavigation : ObjectiveC.NSObjectProtocol {
  @objc var name: Swift.String { get }
  @objc var options: [PRAPI.CatalogNavigationSection] { get }
  @objc var type: PRAPI.CatalogNavigationType { get }
  @objc var value: Any? { get }
  @objc var catalogType: PRAPI.CatalogType { get }
}
@objc public class CatalogNavigationSection : ObjectiveC.NSObject {
  public enum VariantSortOrder {
    case none
    case name
    public static func == (a: PRAPI.CatalogNavigationSection.VariantSortOrder, b: PRAPI.CatalogNavigationSection.VariantSortOrder) -> Swift.Bool
    public func hash(into hasher: inout Swift.Hasher)
    public var hashValue: Swift.Int {
      get
    }
  }
  @objc public var name: Swift.String?
  @objc public var variants: [any PRAPI.CatalogNavigationVariant]
  public init(name: Swift.String? = nil, variants: [any PRAPI.CatalogNavigationVariant], order: PRAPI.CatalogNavigationSection.VariantSortOrder = .none)
  @objc deinit
}
@objc public protocol CatalogNavigationVariant : ObjectiveC.NSObjectProtocol {
  @objc var categoryId: Swift.Int { get }
  @objc var localizedName: Swift.String? { get }
  @objc var count: Swift.Int { get }
}
@objc public protocol CountryNavigationVariant : PRAPI.CatalogNavigationVariant {
  @objc var iso: Swift.String { get }
}
@objc final public class TransientCatalogNavigation : ObjectiveC.NSObject, PRAPI.CatalogNavigation {
  @objc final public let name: Swift.String
  @objc final public let options: [PRAPI.CatalogNavigationSection]
  @objc final public let type: PRAPI.CatalogNavigationType
  @objc final public let value: Any?
  @objc final public let catalogType: PRAPI.CatalogType
  public init(name: Swift.String, options: [PRAPI.CatalogNavigationSection] = [])
  @objc public init(name: Swift.String, type: PRAPI.CatalogNavigationType, value: Any? = nil)
  convenience public init(name: Swift.String, variants: [any PRAPI.CatalogNavigationVariant], order: PRAPI.CatalogNavigationSection.VariantSortOrder = .none)
  @objc deinit
}
@objc extension PRAPI.TransientCatalogNavigation {
  @objc convenience dynamic public init(country: any PRAPI.CountryNavigationVariant)
  @objc convenience dynamic public init(language: PRAPI.PRCountableString)
  @objc convenience dynamic public init(category: PRAPI.PRCountableDictionary)
  @objc convenience dynamic public init(section: PRAPI.PRCountableDictionary)
}
extension PRAPI.PRProduct : PRAnalytics.PaymentOptionsProduct {
}
extension PRCatalogModel.CatalogEntity : PRAPI.CatalogItemDataSourceProtocol, PRAPI.ObservableModel {
  @objc dynamic public var dataProvider: [[any PRAPI.PRCatalogItem]] {
    @objc get
  }
  @objc dynamic public var itemToExclude: (any PRAPI.PRCatalogItem)? {
    @objc get
    @objc set
  }
  @objc dynamic public func layoutType(for section: Swift.Int) -> PRAPI.PRLayoutType
  @objc dynamic public func showDatesOnly(for section: Swift.Int) -> Swift.Bool
  @objc dynamic public var loadingError: (any Swift.Error)? {
    @objc get
  }
  @objc dynamic public var canLoadMore: Swift.Bool {
    @objc get
  }
  @objc dynamic public var isEmpty: Swift.Bool {
    @objc get
  }
  @objc dynamic public var isLoading: Swift.Bool {
    @objc get
  }
  @objc dynamic public var isFailed: Swift.Bool {
    @objc get
  }
  @discardableResult
  @objc dynamic public func load() -> Swift.Bool
  @discardableResult
  @objc dynamic public func loadMore() -> Swift.Bool
  @objc dynamic public func addObserver(_ observer: any PRAPI.DataSourceObserver)
  @objc dynamic public func removeObserver(_ observer: any PRAPI.DataSourceObserver)
  @objc dynamic public func numberOfItems(in section: Swift.Int) -> Swift.Int
  @objc dynamic public func numberOfSections() -> Swift.Int
  @objc dynamic public func title(for section: Swift.Int) -> Swift.String?
  @objc dynamic public var canLoadMoreSilently: Swift.Bool {
    @objc get
  }
}
extension PRCatalogModel.BookContent {
  public func highlight(id: Swift.String) -> PRCatalogModel.Highlight?
  public func updateHighlight(id: Swift.String, color: Swift.String)
  public func removeHighlight(_ highlight: PRCatalogModel.Highlight)
  public func removeHighlight(id: Swift.String)
}
public struct BookReadingFragment : Swift.Encodable {
  public init(filename: Swift.String, fragmentStartOffset: Swift.Int, fragmentEndOffset: Swift.Int, absoluteStartOffset: Swift.Int, absoluteEndOffset: Swift.Int)
  public func encode(to encoder: any Swift.Encoder) throws
}
@objc extension PRAPI.PRMyLibraryItem : PRAPI.DeviceTimeTweakProtected {
}
public protocol PRAppsFlyer {
  func start()
  func logEvent(_ eventName: Swift.String, withValues values: [Swift.AnyHashable : Any]?)
  func registerUninstall(_ deviceToken: Foundation.Data?)
  func setDeepLinkDelegate(_ delegate: ObjectiveC.NSObject)
  func handleOpen(_ url: Foundation.URL?, options: [Swift.AnyHashable : Any]?)
  func `continue`(_ userActivity: Foundation.NSUserActivity?, restorationHandler: (([Any]?) -> Swift.Void)?) -> Swift.Bool
  func shareArticleUrl(id: Swift.String?) async -> Swift.String?
  func setDelegate(_ delegate: ObjectiveC.NSObject)
}
extension PRAPI.PRAppsFlyer {
  public func handleOpen(_ url: Foundation.URL? = nil)
  public func `continue`(_ userActivity: Foundation.NSUserActivity?) -> Swift.Bool
}
@objc @objcMembers public class AutoTranslateLanguagePair : ObjectiveC.NSObject, Swift.Codable {
  @objc final public let sourceISOCode: Swift.String
  @objc final public let destinationISOCode: Swift.String
  @objc public var sourceLanguage: Swift.String? {
    @objc get
    @objc set
  }
  @objc public var destinationLanguage: Swift.String? {
    @objc get
    @objc set
  }
  @objc public var title: Swift.String {
    @objc get
    @objc set
  }
  @objc public init(sourceISOLanguage: Swift.String, destinationISOLanguage: Swift.String)
  @objc override dynamic public func isEqual(_ object: Any?) -> Swift.Bool
  @objc deinit
  public func encode(to encoder: any Swift.Encoder) throws
  required public init(from decoder: any Swift.Decoder) throws
}
extension PRCatalogModel.TitleItem {
  @objc override dynamic public var sortingDate: Foundation.Date? {
    @objc get
  }
}
extension PRAPI.SearchHistoryItem {
  public typealias SearchHistoryCompletion = ([PRAPI.SearchHistoryItem]?, (any Swift.Error)?) -> ()
  public typealias ClearSearchHistoryCompletion = (Swift.Bool, (any Swift.Error)?) -> ()
  @objc final public class func getSearchHistory(pattern: Swift.String, searchArea: PRAPI.PRSmartSearchArea, rowsCount: Swift.Int, completion: @escaping PRAPI.SearchHistoryItem.SearchHistoryCompletion)
  @objc final public class func clearSearchHistory(searchArea: PRAPI.PRSmartSearchArea, completion: @escaping PRAPI.SearchHistoryItem.ClearSearchHistoryCompletion)
  @objc final public class func getSuggestions(pattern: Swift.String, completion: @escaping PRAPI.SearchHistoryItem.SearchHistoryCompletion)
}
@objc extension PRCatalogModel.Document {
  @objc override dynamic public var sourceType: PRCatalogModel.PRSourceType {
    @objc get
  }
}
@objc @_inheritsConvenienceInitializers final public class AuthorizationManager : ObjectiveC.NSObject {
  @objc final public var isAuthorizationMandatory: Swift.Bool {
    @objc get
  }
  @objc final public var shouldAskForAuthorization: Swift.Bool {
    @objc get
  }
  @objc override dynamic public init()
  @objc deinit
}
@objc extension PRAPI.HotSpotManager {
  @objc final public var hotSpotBannerInteracted: Swift.Bool {
    @objc get
    @objc set
  }
  @objc final public var needsRemindUserAboutLocationPermissions: Swift.Bool {
    @objc get
  }
  @objc final public var remindingPostponeDate: Foundation.TimeInterval {
    @objc get
    @objc set
  }
  @objc final public var isUserRespondEnableGift: Swift.Bool {
    @objc get
    @objc set
  }
}
@objc final public class CatalogBanner : PRAPI.PRCatalogSection {
  public enum BannerType {
    case hotspotServices
    case premiumSubscription
    case improveExperience
    case books
    case brazeContentCard
    public static func == (a: PRAPI.CatalogBanner.BannerType, b: PRAPI.CatalogBanner.BannerType) -> Swift.Bool
    public func hash(into hasher: inout Swift.Hasher)
    public var hashValue: Swift.Int {
      get
    }
  }
  final public let type: PRAPI.CatalogBanner.BannerType
  final public let attributedSubtitle: Foundation.NSAttributedString?
  final public var image: UIKit.UIImage?
  final public let impression: (() -> ())?
  final public let action: (() -> ())?
  @objc override final public var sectionType: PRConfiguration.PRCatalogSectionType {
    @objc get
    @objc set
  }
  public init(type: PRAPI.CatalogBanner.BannerType, title: Swift.String? = nil, subtitle: Swift.String? = nil, attributedSubtitle: Foundation.NSAttributedString? = nil, image: UIKit.UIImage? = nil, thumbnail: PRThumbnail.PRThumbnailObject? = nil, impression: (() -> ())? = nil, action: (() -> ())? = nil)
  @objc deinit
}
extension PRAPI.PRSubscription {
  public func getFavoriteCIDs() async throws -> [Swift.String]
}
extension PRAPI.WebAuthenticationSession : Swift.Sendable {}
extension PRAPI.ServiceError : Swift.Equatable {}
extension PRAPI.ServiceError : Swift.Hashable {}
extension PRAPI.CatalogItemDownloadService : Swift.Sendable {}
extension PRAPI.CatalogItemDownloadService.LoadingError : Swift.Equatable {}
extension PRAPI.CatalogItemDownloadService.LoadingError : Swift.Hashable {}
extension PRAPI.ArticleTranslationState : Swift.Equatable {}
extension PRAPI.ArticleTranslationState : Swift.Hashable {}
extension PRAPI.ArticleTranslationState : Swift.RawRepresentable {}
extension PRAPI.MastheadLoadingError : Swift.Equatable {}
extension PRAPI.MastheadLoadingError : Swift.Hashable {}
extension PRAPI.FeaturedAudioAction : Swift.Equatable {}
extension PRAPI.FeaturedAudioAction : Swift.Hashable {}
extension PRAPI.FeaturedAudioAction : Swift.RawRepresentable {}
extension PRAPI.RadioAction : Swift.Equatable {}
extension PRAPI.RadioAction : Swift.Hashable {}
extension PRAPI.RadioAction : Swift.RawRepresentable {}
extension PRAPI.AppleSignInManager : Swift.Sendable {}
extension PRAPI.NTFDataService.DataServiceError : Swift.Equatable {}
extension PRAPI.NTFDataService.DataServiceError : Swift.Hashable {}
extension PRAPI.BookSubservice : Swift.Sendable {}
extension PRAPI.ObservableModelError : Swift.Equatable {}
extension PRAPI.ObservableModelError : Swift.Hashable {}
extension PRAPI.SearchAnalyticsTab : Swift.Equatable {}
extension PRAPI.SearchAnalyticsTab : Swift.Hashable {}
extension PRAPI.DataSourceState : Swift.Equatable {}
extension PRAPI.DataSourceState : Swift.Hashable {}
extension PRAPI.DataSourceLoadingType : Swift.Equatable {}
extension PRAPI.DataSourceLoadingType : Swift.Hashable {}
extension PRAPI.MOService : Swift.Sendable {}
extension PRAPI.BookLicenseUpdateStatus : Swift.Equatable {}
extension PRAPI.BookLicenseUpdateStatus : Swift.Hashable {}
extension PRAPI.BookLicenseUpdateStatus : Swift.RawRepresentable {}
extension PRAPI.PRSponsorshipManagerService.Method : Swift.Equatable {}
extension PRAPI.PRSponsorshipManagerService.Method : Swift.Hashable {}
extension PRAPI.PRSponsorshipManagerService.Method : Swift.RawRepresentable {}
extension PRAPI.ATTrackingStatus : Swift.Equatable {}
extension PRAPI.ATTrackingStatus : Swift.Hashable {}
extension PRAPI.ATTrackingStatus : Swift.RawRepresentable {}
extension PRCatalogModel.CatalogItemContent.Error : Swift.Equatable {}
extension PRCatalogModel.CatalogItemContent.Error : Swift.Hashable {}
extension PRCatalogModel.CatalogItemContent.DownloadingError : Swift.Equatable {}
extension PRCatalogModel.CatalogItemContent.DownloadingError : Swift.Hashable {}
extension PRAPI.EpubContent.ResourceEncryptionInfo : Swift.Equatable {}
extension PRAPI.EpubContent.ResourceEncryptionInfo : Swift.Hashable {}
extension PRAPI.EpubContent.ResourceEncryptionInfo : Swift.RawRepresentable {}
extension PRAPI.TrackingSourceType : Swift.Equatable {}
extension PRAPI.TrackingSourceType : Swift.Hashable {}
extension PRAPI.TrackingSourceType : Swift.RawRepresentable {}
extension PRAPI.AccessError : Swift.Equatable {}
extension PRAPI.AccessError : Swift.Hashable {}
extension PRCatalogModel.CatalogItem.LoadingError : Swift.Equatable {}
extension PRCatalogModel.CatalogItem.LoadingError : Swift.Hashable {}
extension PRAPI.PRSubscription.ArticleFields : Swift.Equatable {}
extension PRAPI.PRSubscription.ArticleFields : Swift.Hashable {}
extension PRAPI.PRSubscription.ArticleFields : Swift.RawRepresentable {}
extension PRAPI.Analytics.Event : Swift.Equatable {}
extension PRAPI.Analytics.Event : Swift.Hashable {}
extension PRAPI.Analytics.Event : Swift.RawRepresentable {}
extension PRAPI.BookLicenseRenewResult.Status : Swift.Equatable {}
extension PRAPI.BookLicenseRenewResult.Status : Swift.Hashable {}
extension PRAPI.BookLicenseRenewResult.Status : Swift.RawRepresentable {}
extension PRDIContainer.DIContainer.DIKey : Swift.Equatable {}
extension PRDIContainer.DIContainer.DIKey : Swift.Hashable {}
extension PRDIContainer.DIContainer.DIKey : Swift.RawRepresentable {}
extension PRAPI.CatalogNavigationType : Swift.Equatable {}
extension PRAPI.CatalogNavigationType : Swift.Hashable {}
extension PRAPI.CatalogNavigationType : Swift.RawRepresentable {}
extension PRAPI.CatalogType : Swift.Equatable {}
extension PRAPI.CatalogType : Swift.Hashable {}
extension PRAPI.CatalogType : Swift.RawRepresentable {}
extension PRAPI.CatalogNavigationSection.VariantSortOrder : Swift.Equatable {}
extension PRAPI.CatalogNavigationSection.VariantSortOrder : Swift.Hashable {}
extension PRAPI.CatalogBanner.BannerType : Swift.Equatable {}
extension PRAPI.CatalogBanner.BannerType : Swift.Hashable {}
